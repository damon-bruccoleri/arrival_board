// arrival_board.c — QM8 Arrival Board for Raspberry Pi (HDMI/TV)
// Build: make
// Run:   MTA_KEY=xxxxx ./arrival_board
//
// Uses MTA Bus Time SIRI StopMonitoring JSON endpoint (requires key).  :contentReference[oaicite:4]{index=4}
// Displays arrivals for stop 501627 (SPRINGFIELD BLVD/73 AV). :contentReference[oaicite:5]{index=5}

#define _GNU_SOURCE
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>
#include <curl/curl.h>
#include <cjson/cJSON.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#ifndef timegm
// On glibc timegm exists; if not, this is a fallback (less ideal).
static time_t timegm_fallback(struct tm *tm) {
  char *tz = getenv("TZ");
  setenv("TZ","UTC",1);
  tzset();
  time_t t = mktime(tm);
  if (tz) setenv("TZ", tz, 1); else unsetenv("TZ");
  tzset();
  return t;
}
#define timegm timegm_fallback
#endif

typedef struct {
  char vehicle_ref[64];
  char trip_ref[128];
  char line_name[32];      // PublishedLineName (e.g. "QM8") :contentReference[oaicite:6]{index=6}
  char headsign[160];      // DestinationName :contentReference[oaicite:7]{index=7}
  char presentable[80];    // PresentableDistance :contentReference[oaicite:8]{index=8}
  int  stops_from_call;    // StopsFromCall :contentReference[oaicite:9]{index=9}
  time_t expected_arrival; // ExpectedArrivalTime :contentReference[oaicite:10]{index=10}
  int has_eta;
} Arrival;

typedef struct {
  Arrival *items;
  size_t len;
} ArrivalList;

static void arrivals_free(ArrivalList *l) {
  free(l->items);
  l->items = NULL;
  l->len = 0;
}

static int str_icontains(const char *hay, const char *needle) {
  if (!hay || !needle) return 0;
  size_t n = strlen(needle);
  if (n == 0) return 1;
  for (const char *p = hay; *p; p++) {
    size_t i = 0;
    while (p[i] && i < n && tolower((unsigned char)p[i]) == tolower((unsigned char)needle[i])) i++;
    if (i == n) return 1;
  }
  return 0;
}

// Parse ISO8601 like 2015-06-04T10:46:08.361-04:00 into epoch.
// We parse base seconds + timezone offset; milliseconds ignored.
static int iso8601_to_epoch(const char *s, time_t *out) {
  if (!s || strlen(s) < 19) return 0;

  int Y,M,D,h,m,sec;
  if (sscanf(s, "%4d-%2d-%2dT%2d:%2d:%2d", &Y,&M,&D,&h,&m,&sec) != 6) return 0;

  struct tm tm = {0};
  tm.tm_year = Y - 1900;
  tm.tm_mon  = M - 1;
  tm.tm_mday = D;
  tm.tm_hour = h;
  tm.tm_min  = m;
  tm.tm_sec  = sec;

  // Find timezone part: 'Z' or ±HH:MM
  const char *tzp = s + 19;
  // skip fractional seconds
  if (*tzp == '.') {
    while (*tzp && *tzp != 'Z' && *tzp != '+' && *tzp != '-') tzp++;
  }

  int offset_sign = 0, off_h = 0, off_m = 0;
  if (*tzp == 'Z') {
    offset_sign = 0;
  } else if (*tzp == '+' || *tzp == '-') {
    offset_sign = (*tzp == '-') ? -1 : 1;
    // format ±HH:MM
    if (sscanf(tzp+1, "%2d:%2d", &off_h, &off_m) != 2) { off_h = 0; off_m = 0; }
  }

  time_t t_utc = timegm(&tm);
  if (offset_sign != 0) {
    int offset = offset_sign * (off_h*3600 + off_m*60);
    // Local time with offset -> UTC = local - offset
    t_utc -= offset;
  }
  *out = t_utc;
  return 1;
}

typedef struct {
  char *data;
  size_t size;
} MemBuf;

static size_t curl_write_cb(void *contents, size_t size, size_t nmemb, void *userp) {
  size_t realsz = size * nmemb;
  MemBuf *mem = (MemBuf*)userp;
  char *ptr = realloc(mem->data, mem->size + realsz + 1);
  if (!ptr) return 0;
  mem->data = ptr;
  memcpy(&(mem->data[mem->size]), contents, realsz);
  mem->size += realsz;
  mem->data[mem->size] = 0;
  return realsz;
}

static char* http_get(const char *url) {
  CURL *curl = curl_easy_init();
  if (!curl) return NULL;

  MemBuf chunk = {0};
  curl_easy_setopt(curl, CURLOPT_URL, url);
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_cb);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);
  curl_easy_setopt(curl, CURLOPT_USERAGENT, "arrival-board/1.0");
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(curl, CURLOPT_TIMEOUT, 20L);

  CURLcode res = curl_easy_perform(curl);
  long code = 0;
  curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &code);
  curl_easy_cleanup(curl);

  if (res != CURLE_OK || code < 200 || code >= 300) {
    free(chunk.data);
    return NULL;
  }
  return chunk.data; // caller frees
}

static const cJSON* jget(const cJSON *obj, const char *key) {
  if (!obj) return NULL;
  return cJSON_GetObjectItemCaseSensitive((cJSON*)obj, key);
}
static const char* jstr(const cJSON *obj, const char *key) {
  const cJSON *v = jget(obj, key);
  if (cJSON_IsString(v) && v->valuestring) return v->valuestring;
  return NULL;
}
static int jint(const cJSON *obj, const char *key, int def) {
  const cJSON *v = jget(obj, key);
  if (cJSON_IsNumber(v)) return v->valueint;
  return def;
}

static int arrival_cmp(const void *a, const void *b) {
  const Arrival *A = (const Arrival*)a;
  const Arrival *B = (const Arrival*)b;
  if (A->has_eta && B->has_eta) {
    if (A->expected_arrival < B->expected_arrival) return -1;
    if (A->expected_arrival > B->expected_arrival) return 1;
    return 0;
  }
  if (A->has_eta) return -1;
  if (B->has_eta) return 1;
  return 0;
}

// Extract arrivals from SIRI StopMonitoring JSON
static int parse_arrivals(const char *json, ArrivalList *out, const char *route_filter) {
  arrivals_free(out);

  cJSON *root = cJSON_Parse(json);
  if (!root) return 0;

  const cJSON *siri = jget(root, "Siri");
  const cJSON *sd = jget(siri, "ServiceDelivery");
  const cJSON *smd = jget(sd, "StopMonitoringDelivery");

  // StopMonitoringDelivery may be an array
  const cJSON *delivery0 = smd;
  if (cJSON_IsArray(smd)) delivery0 = cJSON_GetArrayItem((cJSON*)smd, 0);

  const cJSON *visits = jget(delivery0, "MonitoredStopVisit");
  if (!visits || !cJSON_IsArray(visits)) {
    cJSON_Delete(root);
    return 1; // no visits is not fatal
  }

  size_t cap = 16;
  out->items = (Arrival*)calloc(cap, sizeof(Arrival));
  out->len = 0;

  cJSON *visit = NULL;
  cJSON_ArrayForEach(visit, (cJSON*)visits) {
    const cJSON *mvj = jget(visit, "MonitoredVehicleJourney");
    if (!mvj) continue;

    const char *published = jstr(mvj, "PublishedLineName"); // route_short_name :contentReference[oaicite:11]{index=11}
    if (route_filter && route_filter[0] && (!published || strcmp(published, route_filter) != 0)) {
      continue;
    }

    if (out->len == cap) {
      cap *= 2;
      out->items = (Arrival*)realloc(out->items, cap * sizeof(Arrival));
    }
    Arrival *A = &out->items[out->len];
    memset(A, 0, sizeof(*A));

    if (published) snprintf(A->line_name, sizeof(A->line_name), "%s", published);

    const char *headsign = jstr(mvj, "DestinationName"); // trip_headsign :contentReference[oaicite:12]{index=12}
    if (headsign) snprintf(A->headsign, sizeof(A->headsign), "%s", headsign);

    const char *veh = jstr(mvj, "VehicleRef");
    if (veh) snprintf(A->vehicle_ref, sizeof(A->vehicle_ref), "%s", veh);

    // Trip ref is inside FramedVehicleJourneyRef.DatedVehicleJourneyRef :contentReference[oaicite:13]{index=13}
    const cJSON *fvjr = jget(mvj, "FramedVehicleJourneyRef");
    const char *trip = jstr(fvjr, "DatedVehicleJourneyRef");
    if (trip) snprintf(A->trip_ref, sizeof(A->trip_ref), "%s", trip);

    const cJSON *mc = jget(mvj, "MonitoredCall");
    const char *eta = jstr(mc, "ExpectedArrivalTime"); // :contentReference[oaicite:14]{index=14}
    if (eta) {
      time_t t;
      if (iso8601_to_epoch(eta, &t)) { A->expected_arrival = t; A->has_eta = 1; }
    }

    // Distances extension :contentReference[oaicite:15]{index=15}
    const cJSON *ext = jget(mc, "Extensions");
    const cJSON *dist = jget(ext, "Distances");
    const char *pd = jstr(dist, "PresentableDistance");
    if (pd) snprintf(A->presentable, sizeof(A->presentable), "%s", pd);

    A->stops_from_call = jint(dist, "StopsFromCall", -1);

    out->len++;
  }

  qsort(out->items, out->len, sizeof(Arrival), arrival_cmp);

  cJSON_Delete(root);
  return 1;
}

static void draw_text(SDL_Renderer *r, TTF_Font *font, int x, int y, SDL_Color c, const char *text) {
  if (!text || !*text) return;
  SDL_Surface *s = TTF_RenderUTF8_Blended(font, text, c);
  if (!s) return;
  SDL_Texture *t = SDL_CreateTextureFromSurface(r, s);
  SDL_Rect dst = { x, y, s->w, s->h };
  SDL_FreeSurface(s);
  if (!t) return;
  SDL_RenderCopy(r, t, NULL, &dst);
  SDL_DestroyTexture(t);
}

static int minutes_until(time_t now, time_t eta) {
  double sec = difftime(eta, now);
  int m = (int)(sec / 60.0);
  if (sec > 0 && sec < 60) return 1; // show "1" when under a minute
  return m;
}

static void safe_str(char *dst, size_t dstsz, const char *src, const char *fallback) {
  snprintf(dst, dstsz, "%s", (src && *src) ? src : fallback);
}

static int key_in_prev(const char *key, char **prev_keys, size_t prev_n) {
  for (size_t i=0;i<prev_n;i++) if (prev_keys[i] && strcmp(prev_keys[i], key)==0) return 1;
  return 0;
}

int main(int argc, char **argv) {
  (void)argc; (void)argv;

  const char *api_key = getenv("MTA_KEY");
  if (!api_key || !*api_key) {
    fprintf(stderr, "Missing MTA_KEY env var (your Bus Time API key). See MTA StopMonitoring docs.\n");
    return 2;
  }

  const char *stop_id = getenv("STOP_ID"); if (!stop_id || !*stop_id) stop_id = "501627";
  const char *route_filter = getenv("ROUTE_FILTER"); if (!route_filter) route_filter = "QM8";
  const char *operator_ref = getenv("OPERATOR_REF"); if (!operator_ref || !*operator_ref) operator_ref = "MTA";
  const char *poll_s = getenv("POLL_SECONDS"); int poll_seconds = poll_s ? atoi(poll_s) : 20;
  if (poll_seconds < 10) poll_seconds = 10;

  const char *sound_new_path = getenv("SOUND_NEW");
  const char *sound_arr_path = getenv("SOUND_ARRIVE");
  if (!sound_new_path) sound_new_path = "/usr/share/sounds/alsa/Front_Center.wav";
  if (!sound_arr_path) sound_arr_path = "/usr/share/sounds/alsa/Front_Left.wav";

  // Build URL (version=2 preferred) :contentReference[oaicite:16]{index=16}
  char url[1024];
  snprintf(url, sizeof(url),
    "https://bustime.mta.info/api/siri/stop-monitoring.json"
    "?key=%s&version=2&OperatorRef=%s&MonitoringRef=%s"
    "&MaximumStopVisits=20&StopMonitoringDetailLevel=minimum",
    api_key, operator_ref, stop_id);

  if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
    fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
    return 1;
  }
  if (TTF_Init() != 0) {
    fprintf(stderr, "TTF_Init failed: %s\n", TTF_GetError());
    return 1;
  }
  if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
    fprintf(stderr, "Mix_OpenAudio failed (audio may be disabled): %s\n", Mix_GetError());
  }

  Mix_Chunk *snd_new = Mix_LoadWAV(sound_new_path);
  Mix_Chunk *snd_arr = Mix_LoadWAV(sound_arr_path);

  const char *font_path = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf";
  SDL_Window *win = SDL_CreateWindow("Arrival Board",
    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
    1280, 720, SDL_WINDOW_FULLSCREEN_DESKTOP);
  if (!win) { fprintf(stderr, "SDL_CreateWindow: %s\n", SDL_GetError()); return 1; }

  SDL_Renderer *ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_SOFTWARE);
  if (!ren) { fprintf(stderr, "SDL_CreateRenderer: %s\n", SDL_GetError()); return 1; }

  int W, H;
  SDL_GetRendererOutputSize(ren, &W, &H);

  // Scale fonts by screen height
  float scale = (float)H / 1080.0f;
  int font_big_sz = (int)(86 * scale);
  int font_med_sz = (int)(42 * scale);
  int font_small_sz = (int)(28 * scale);

  TTF_Font *font_big = TTF_OpenFont(font_path, font_big_sz);
  TTF_Font *font_med = TTF_OpenFont(font_path, font_med_sz);
  TTF_Font *font_small = TTF_OpenFont(font_path, font_small_sz);
  if (!font_big || !font_med || !font_small) {
    fprintf(stderr, "TTF_OpenFont failed. Is DejaVuSans installed?\n");
    return 1;
  }

  ArrivalList cur = {0};
  ArrivalList prev = {0};

  // Track prior “keys” for new-bus detection, and per-bus “arrive played”
  char **prev_keys = NULL; size_t prev_keys_n = 0;
  char **arrived_keys = NULL; size_t arrived_n = 0;

  Uint32 last_poll = 0;

  SDL_Event e;
  int running = 1;

  while (running) {
    while (SDL_PollEvent(&e)) {
      if (e.type == SDL_QUIT) running = 0;
      if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE) running = 0;
    }

    Uint32 now_ms = SDL_GetTicks();
    if (now_ms - last_poll > (Uint32)(poll_seconds * 1000)) {
      last_poll = now_ms;

      char *body = http_get(url);
      if (body) {
        arrivals_free(&prev);
        prev = cur; // shallow move (cur->prev)
        cur.items = NULL; cur.len = 0;

        parse_arrivals(body, &cur, route_filter);
        free(body);

        // Build current key list
        char **cur_keys = NULL; size_t cur_n = 0;
        cur_keys = (char**)calloc(cur.len ? cur.len : 1, sizeof(char*));

        for (size_t i=0;i<cur.len;i++) {
          char key[256];
          snprintf(key, sizeof(key), "%s|%s",
                   cur.items[i].vehicle_ref[0]?cur.items[i].vehicle_ref:"?",
                   cur.items[i].trip_ref[0]?cur.items[i].trip_ref:"?");
          cur_keys[cur_n++] = strdup(key);

          // New-bus sound: key not in prev snapshot
          if (!key_in_prev(key, prev_keys, prev_keys_n)) {
            if (snd_new) Mix_PlayChannel(-1, snd_new, 0);
          }

          // Arriving sound: trigger when "at stop"/"approaching" OR ETA <= 0 minutes
          time_t now = time(NULL);
          int mins = cur.items[i].has_eta ? minutes_until(now, cur.items[i].expected_arrival) : 9999;
          int arriving = str_icontains(cur.items[i].presentable, "at stop") ||
                         str_icontains(cur.items[i].presentable, "approaching") ||
                         (cur.items[i].has_eta && mins <= 0);

          if (arriving && !key_in_prev(key, arrived_keys, arrived_n)) {
            if (snd_arr) Mix_PlayChannel(-1, snd_arr, 0);
            arrived_keys = (char**)realloc(arrived_keys, (arrived_n+1)*sizeof(char*));
            arrived_keys[arrived_n++] = strdup(key);
          }
        }

        // replace prev_keys with cur_keys
        for (size_t i=0;i<prev_keys_n;i++) free(prev_keys[i]);
        free(prev_keys);
        prev_keys = cur_keys;
        prev_keys_n = cur_n;
      }
    }

    // Render
    SDL_SetRenderDrawColor(ren, 0, 0, 0, 255);
    SDL_RenderClear(ren);

    SDL_Color white = {240,240,240,255};
    SDL_Color dim   = {180,180,180,255};
    SDL_Color accent= {80, 200, 255,255};

    // Center a “board” region
    int board_w = (int)(W * 0.78f);
    if (board_w > 2200) board_w = 2200;
    int board_x = (W - board_w)/2;

    char header[256];
    snprintf(header, sizeof(header), "%s — Stop %s", route_filter[0]?route_filter:"", stop_id);
    draw_text(ren, font_med, board_x, (int)(20*scale), accent, header);

    // stop name note
    draw_text(ren, font_small, board_x, (int)(75*scale), dim, "Springfield Blvd / 73 Av");

    // clock (top-right of board)
    time_t now = time(NULL);
    struct tm lt; localtime_r(&now, &lt);
    char clockbuf[64];
    strftime(clockbuf, sizeof(clockbuf), "%I:%M:%S %p", &lt);
    int clock_x = board_x + board_w - (int)(360*scale);
    draw_text(ren, font_small, clock_x, (int)(30*scale), dim, clockbuf);

    int y = (int)(120*scale);
    int row_h = (int)(180*scale);
    int max_rows = (H - y - (int)(40*scale)) / row_h;
    if (max_rows < 1) max_rows = 1;

    if (cur.len == 0) {
      draw_text(ren, font_med, board_x, y, white, "No QM8 trips currently listed.");
      draw_text(ren, font_small, board_x, y + (int)(60*scale), dim, "This may be outside service hours, or predictions may be temporarily unavailable.");
    } else {
      for (int i=0; i<max_rows && (size_t)i<cur.len; i++) {
        Arrival *A = &cur.items[i];

        // Left: minutes / status
        char left[32];
        if (!A->has_eta) {
          snprintf(left, sizeof(left), "--");
        } else {
          int mins = minutes_until(now, A->expected_arrival);
          if (mins <= 0) snprintf(left, sizeof(left), "DUE");
          else snprintf(left, sizeof(left), "%d", mins);
        }

        int left_x = board_x;
        int row_y = y + i*row_h;

        draw_text(ren, font_big, left_x, row_y + (int)(20*scale), white, left);

        // Left: countdown (minutes + seconds) + stops
        int left_x = board_x;
        int row_y = y + i*row_h;

        char big[32], small[32], stopsline[64];
        if (!A->has_eta) {
          snprintf(big, sizeof(big), "--");
          snprintf(small, sizeof(small), "");
        } else {
          int sec = (int)difftime(A->expected_arrival, now);
          if (sec <= 0) {
            snprintf(big, sizeof(big), "DUE");
            snprintf(small, sizeof(small), "0s");
          } else {
            int mm = sec / 60;
            int ss = sec % 60;
            snprintf(big, sizeof(big), "%dm", mm);
            snprintf(small, sizeof(small), "%ds", ss);
          }
        }

        // Push the big digits down so they don't clip
        draw_text(ren, font_big, left_x, row_y + (int)(55*scale), white, big);

        // Seconds beside the minutes
        if (small[0]) {
          draw_text(ren, font_med, left_x + (int)(210*scale), row_y + (int)(75*scale), dim, small);
        }

        // Stops away under the countdown
        if (A->stops_from_call >= 0) snprintf(stopsline, sizeof(stopsline), "%d stops", A->stops_from_call);
        else snprintf(stopsline, sizeof(stopsline), "stops: --");
        draw_text(ren, font_small, left_x, row_y + (int)(140*scale), dim, stopsline);

        // Right: route + destination + distance
        char right1[220], right2[220];
        if (A->line_name[0] && A->headsign[0]) {
          snprintf(right1, sizeof(right1), "%s → %s", A->line_name, A->headsign);
        } else if (A->headsign[0]) {
          snprintf(right1, sizeof(right1), "%s", A->headsign);
        } else {
          snprintf(right1, sizeof(right1), "Bus");
        }

        if (A->presentable[0]) snprintf(right2, sizeof(right2), "%s", A->presentable);
        else snprintf(right2, sizeof(right2), "—");

        int right_x = board_x + (int)(520*scale);
        draw_text(ren, font_med, right_x, row_y + (int)(65*scale), white, right1);
        draw_text(ren, font_small, right_x, row_y + (int)(125*scale), dim, right2);

        // Right: headsign + distance
        char right1[220], right2[220];
        safe_str(right1, sizeof(right1), A->headsign, "QM8");
        if (str_icontains(right1, "super")) {
          // little hint without relying on separate route name
          strncat(right1, "  [SUPER]", sizeof(right1)-strlen(right1)-1);
        }

        if (A->presentable[0]) {
          snprintf(right2, sizeof(right2), "%s", A->presentable);
        } else if (A->stops_from_call >= 0) {
          snprintf(right2, sizeof(right2), "%d stops away", A->stops_from_call);
        } else {
          snprintf(right2, sizeof(right2), "—");
        }

        int right_x = board_x + (int)(260*scale);
        draw_text(ren, font_med, right_x, row_y + (int)(10*scale), white, right1);
        draw_text(ren, font_small, right_x, row_y + (int)(75*scale), dim, right2);

        // divider
        SDL_SetRenderDrawColor(ren, 40, 40, 40, 255);
        SDL_RenderDrawLine(ren, board_x, row_y + row_h - (int)(10*scale), board_x + board_w, row_y + row_h - (int)(10*scale));
      }
    }

    SDL_RenderPresent(ren);
    SDL_Delay(16);
  }

  // Cleanup
  arrivals_free(&cur);
  arrivals_free(&prev);

  for (size_t i=0;i<prev_keys_n;i++) free(prev_keys[i]);
  free(prev_keys);
  for (size_t i=0;i<arrived_n;i++) free(arrived_keys[i]);
  free(arrived_keys);

  if (snd_new) Mix_FreeChunk(snd_new);
  if (snd_arr) Mix_FreeChunk(snd_arr);
  Mix_CloseAudio();

  TTF_CloseFont(font_big);
  TTF_CloseFont(font_med);
  TTF_CloseFont(font_small);

  SDL_DestroyRenderer(ren);
  SDL_DestroyWindow(win);

  TTF_Quit();
  SDL_Quit();
  return 0;
}
