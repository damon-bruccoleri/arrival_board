#define _POSIX_C_SOURCE 200809L
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <curl/curl.h>
#include <cjson/cJSON.h>

#include <ctype.h>
#include <math.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/wait.h>

#define BUILD_TAG "AB_BUILD_2026-01-14_1705"

static volatile sig_atomic_t g_quit = 0;
static void on_sig(int s){ (void)s; g_quit = 1; }

static int env_int(const char *k, int defv){
  const char *v = getenv(k);
  if(!v || !*v) return defv;
  char *e=NULL; long n=strtol(v,&e,10);
  if(e==v) return defv;
  return (int)n;
}

static void safe_copy(char *dst, size_t dstsz, const char *src){
  if(!dst || dstsz==0) return;
  snprintf(dst, dstsz, "%s", src?src:"");
}

static const cJSON* jget(const cJSON *obj, const char *key){
  if(!obj || !cJSON_IsObject(obj)) return NULL;
  return cJSON_GetObjectItemCaseSensitive((cJSON*)obj, key);
}

static const char* json_string_or_first(const cJSON *v){
  if(!v) return NULL;
  if(cJSON_IsString(v) && v->valuestring) return v->valuestring;
  if(cJSON_IsArray(v)){
    const cJSON *z=cJSON_GetArrayItem((cJSON*)v,0);
    if(z && cJSON_IsString(z) && z->valuestring) return z->valuestring;
  }
  return NULL;
}

static const char* jstr1(const cJSON *obj, const char *key){
  return json_string_or_first(jget(obj,key));
}

static double jdbl(const cJSON *obj, const char *key, double defv){
  const cJSON *v=jget(obj,key);
  if(v && cJSON_IsNumber(v)) return v->valuedouble;
  return defv;
}

static int jint(const cJSON *obj, const char *key, int defv){
  const cJSON *v=jget(obj,key);
  if(v && cJSON_IsNumber(v)) return v->valueint;
  return defv;
}

static int iso8601_to_epoch(const char *s, time_t *out){
  if(!s || !out) return 0;
  int Y=0,M=0,D=0,h=0,m=0,sec=0;
  if(sscanf(s,"%4d-%2d-%2dT%2d:%2d:%2d",&Y,&M,&D,&h,&m,&sec)!=6) return 0;

  const char *tz=s;
  while(*tz && !(*tz=='Z' || *tz=='+' || *tz=='-')) tz++;

  char sign=0; int tzh=0,tzm=0;
  if(*tz=='Z') sign='Z';
  else if(*tz=='+' || *tz=='-'){
    sign=*tz;
    if(sscanf(tz+1,"%2d:%2d",&tzh,&tzm)<1){ tzh=0; tzm=0; }
  }

  struct tm tmv; memset(&tmv,0,sizeof(tmv));
  tmv.tm_year=Y-1900; tmv.tm_mon=M-1; tmv.tm_mday=D;
  tmv.tm_hour=h; tmv.tm_min=m; tmv.tm_sec=sec;

#if defined(__linux__)
  time_t t=timegm(&tmv);
#else
  time_t t=mktime(&tmv);
#endif
  if(t==(time_t)-1) return 0;

  if(sign=='Z'){ *out=t; return 1; }
  if(sign=='+' || sign=='-'){
    int off=tzh*3600 + tzm*60;
    if(sign=='+') t -= off; else t += off;
  }
  *out=t; return 1;
}

/* ---- curl ---- */
typedef struct { char *data; size_t size; } MemBuf;

static size_t curl_write_cb(void *contents, size_t size, size_t nmemb, void *userp){
  size_t realsz=size*nmemb;
  MemBuf *m=(MemBuf*)userp;
  char *p=realloc(m->data, m->size + realsz + 1);
  if(!p) return 0;
  m->data=p;
  memcpy(m->data + m->size, contents, realsz);
  m->size += realsz;
  m->data[m->size]='\0';
  return realsz;
}

static char* http_get(const char *url, long *code_out){
  CURL *c=curl_easy_init();
  if(!c) return NULL;
  MemBuf m={0};
  curl_easy_setopt(c, CURLOPT_URL, url);
  curl_easy_setopt(c, CURLOPT_WRITEFUNCTION, curl_write_cb);
  curl_easy_setopt(c, CURLOPT_WRITEDATA, &m);
  curl_easy_setopt(c, CURLOPT_USERAGENT, "arrival_board/1.0");
  curl_easy_setopt(c, CURLOPT_TIMEOUT, 15L);
  curl_easy_setopt(c, CURLOPT_FOLLOWLOCATION, 1L);
  CURLcode r=curl_easy_perform(c);
  long code=0; curl_easy_getinfo(c, CURLINFO_RESPONSE_CODE, &code);
  if(code_out) *code_out=code;
  curl_easy_cleanup(c);
  if(r!=CURLE_OK){ free(m.data); return NULL; }
  return m.data;
}

/* ---- aplay ---- */
static void play_wav_async(const char *wav){
  if(!wav || !*wav) return;
  const char *dev=getenv("APLAY_DEVICE");
  pid_t pid=fork();
  if(pid==0){
    if(dev && *dev) execlp("aplay","aplay","-q","-D",dev,wav,(char*)NULL);
    else execlp("aplay","aplay","-q",wav,(char*)NULL);
    _exit(127);
  }
  int st=0; waitpid(pid,&st,WNOHANG);
}

/* ---- model ---- */
typedef struct {
  char route[24];
  char dest[128];
  char vehicle[48];
  char stop_name[128];
  int has_expected;
  time_t expected;
  time_t aimed;
  double dist_m;
  int stops;
  char presentable[96];
  char progress[48];
} Arrival;

typedef struct { Arrival *a; int n, cap; } ArrivalList;

static void list_init(ArrivalList *l){ memset(l,0,sizeof(*l)); }
static void list_free(ArrivalList *l){ free(l->a); l->a=NULL; l->n=l->cap=0; }
static void list_push(ArrivalList *l, const Arrival *x){
  if(l->n+1>l->cap){
    int nc = l->cap? l->cap*2 : 32;
    Arrival *p=realloc(l->a, (size_t)nc*sizeof(Arrival));
    if(!p) return;
    l->a=p; l->cap=nc;
  }
  l->a[l->n++]=*x;
}

static int cmp_arr(const void *pa, const void *pb){
  const Arrival *a=(const Arrival*)pa, *b=(const Arrival*)pb;
  time_t ta=a->has_expected?a->expected:a->aimed;
  time_t tb=b->has_expected?b->expected:b->aimed;
  if(ta<tb) return -1;
  if(ta>tb) return 1;
  return 0;
}

static void join_progress(const cJSON *v, char *out, size_t outsz){
  out[0]='\0';
  if(!v) return;
  if(cJSON_IsArray(v)){
    int first=1;
    cJSON *it=NULL;
    cJSON_ArrayForEach(it,(cJSON*)v){
      const char *s=json_string_or_first(it);
      if(!s || !*s) continue;
      if(!first) strncat(out,",",outsz-strlen(out)-1);
      strncat(out,s,outsz-strlen(out)-1);
      first=0;
    }
  } else {
    const char *s=json_string_or_first(v);
    if(s) safe_copy(out,outsz,s);
  }
}

static void parse_dist(const cJSON *mvj, Arrival *a){
  a->dist_m=-1.0; a->stops=-1; a->presentable[0]='\0';
  const cJSON *mon=jget(mvj,"MonitoredCall");
  if(!mon) return;
  const cJSON *ext=jget(mon,"Extensions");
  if(!ext) return;
  const cJSON *dist=jget(ext,"Distances");
  if(!dist) return;
  a->dist_m = jdbl(dist,"DistanceFromCall",-1.0);
  a->stops  = jint(dist,"StopsFromCall",-1);
  const char *p=jstr1(dist,"PresentableDistance");
  if(p) safe_copy(a->presentable,sizeof(a->presentable),p);
}

static int parse_arrivals(const char *json, ArrivalList *out){
  cJSON *root=cJSON_Parse(json);
  if(!root) return 0;

  const cJSON *Siri=jget(root,"Siri");
  const cJSON *SD=Siri?jget(Siri,"ServiceDelivery"):NULL;
  const cJSON *SMD=SD?jget(SD,"StopMonitoringDelivery"):NULL;

  const cJSON *delivery=NULL;
  if(cJSON_IsArray(SMD)) delivery=cJSON_GetArrayItem((cJSON*)SMD,0);
  else delivery=SMD;

  const cJSON *vis=delivery?jget(delivery,"MonitoredStopVisit"):NULL;
  if(!vis || !cJSON_IsArray(vis)){ cJSON_Delete(root); return 0; }

  cJSON *visit=NULL;
  cJSON_ArrayForEach(visit,(cJSON*)vis){
    const cJSON *mvj=jget(visit,"MonitoredVehicleJourney");
    if(!mvj) continue;

    Arrival a; memset(&a,0,sizeof(a));
    const char *line=jstr1(mvj,"PublishedLineName");
    if(!line) line=jstr1(mvj,"LineRef");
    safe_copy(a.route,sizeof(a.route), line?line:"?");

    const char *dest=jstr1(mvj,"DestinationName");
    safe_copy(a.dest,sizeof(a.dest), dest?dest:"");

    const char *veh=jstr1(mvj,"VehicleRef");
    safe_copy(a.vehicle,sizeof(a.vehicle), veh?veh:"");

    join_progress(jget(mvj,"ProgressStatus"), a.progress, sizeof(a.progress));

    const cJSON *mon=jget(mvj,"MonitoredCall");
    const char *stopnm=mon?jstr1(mon,"StopPointName"):NULL;
    safe_copy(a.stop_name,sizeof(a.stop_name), stopnm?stopnm:"");

    if(mon){
      time_t texp=0, taim=0;
      const char *exp=jstr1(mon,"ExpectedArrivalTime");
      const char *aim=jstr1(mon,"AimedArrivalTime");
      if(exp && iso8601_to_epoch(exp,&texp)){ a.has_expected=1; a.expected=texp; }
      if(aim && iso8601_to_epoch(aim,&taim)){ a.aimed=taim; }
      if(!a.has_expected){
        const char *expd=jstr1(mon,"ExpectedDepartureTime");
        if(expd && iso8601_to_epoch(expd,&texp)){ a.has_expected=1; a.expected=texp; }
      }
      if(a.aimed==0){
        const char *aimd=jstr1(mon,"AimedDepartureTime");
        if(aimd && iso8601_to_epoch(aimd,&taim)) a.aimed=taim;
      }
    }

    parse_dist(mvj,&a);

    if(!a.has_expected && a.aimed==0) continue;
    list_push(out,&a);
  }

  cJSON_Delete(root);
  return 1;
}

/* ---- rendering helpers with truncation ---- */
static int text_w(TTF_Font *f, const char *t){
  int w=0,h=0;
  if(!t||!*t) return 0;
  if(TTF_SizeUTF8(f,t,&w,&h)!=0) return 0;
  return w;
}
static int utf8_cut(const char *s, int cut){
  if(cut<=0) return 0;
  int n=(int)strlen(s);
  if(cut>n) cut=n;
  while(cut>0 && ((unsigned char)s[cut] & 0xC0)==0x80) cut--;
  return cut;
}
static void truncate_fit(TTF_Font *f, const char *in, char *out, size_t outsz, int maxw){
  safe_copy(out,outsz,in?in:"");
  if(!in || !*in) return;
  if(text_w(f,out)<=maxw) return;

  const char *dots="...";
  int lo=0, hi=(int)strlen(in), best=0;
  while(hi>0 && ((unsigned char)in[hi-1] & 0xC0)==0x80) hi--;

  while(lo<=hi){
    int mid=(lo+hi)/2;
    mid=utf8_cut(in,mid);

    char tmp[512];
    int m=mid; if(m<0)m=0; if(m>(int)sizeof(tmp)-1)m=(int)sizeof(tmp)-1;
    memcpy(tmp,in,(size_t)m); tmp[m]='\0';
    strncat(tmp,dots,sizeof(tmp)-strlen(tmp)-1);

    if(text_w(f,tmp)<=maxw){ best=mid; lo=mid+1; }
    else hi=mid-1;
  }

  if(best<=0){ safe_copy(out,outsz,dots); return; }
  int cut=utf8_cut(in,best);
  if((size_t)cut>=outsz) cut=(int)outsz-1;
  memcpy(out,in,(size_t)cut); out[cut]='\0';
  strncat(out,dots,outsz-strlen(out)-1);
}

static SDL_Texture* make_text(SDL_Renderer *r, TTF_Font *f, SDL_Color c, const char *txt, int *w, int *h){
  if(!txt||!*txt) return NULL;
  SDL_Surface *s=TTF_RenderUTF8_Solid(f,txt,c);
  if(!s){ fprintf(stderr,"TTF_Render failed (%s): '%s'\n",TTF_GetError(),txt); return NULL; }
  SDL_Texture *t=SDL_CreateTextureFromSurface(r,s);
  if(!t){
    fprintf(stderr,"CreateTextureFromSurface failed (%s): '%s'\n",SDL_GetError(),txt);
    SDL_FreeSurface(s); return NULL;
  }
  if(w) *w=s->w;
  if(h) *h=s->h;
  SDL_FreeSurface(s);
  return t;
}

static void draw_fit(SDL_Renderer *r, int maxTexW, TTF_Font *f, int x, int y, int maxw, SDL_Color c, const char *txt){
  if(!txt||!*txt) return;
  int hard=maxw;
  if(maxTexW>0 && hard>maxTexW-20) hard=maxTexW-20;
  if(hard<50) hard=50;

  char buf[512];
  truncate_fit(f,txt,buf,sizeof(buf),hard);

  int tw=0, th=0;
  SDL_Texture *t=make_text(r,f,c,buf,&tw,&th);
  if(!t) return;
  SDL_Rect dst={x,y,tw,th};
  SDL_RenderCopy(r,t,NULL,&dst);
  SDL_DestroyTexture(t);
}

static void fmt_hms(char *b,size_t n,time_t t){
  struct tm tmv; localtime_r(&t,&tmv);
  snprintf(b,n,"%02d:%02d:%02d",tmv.tm_hour,tmv.tm_min,tmv.tm_sec);
}
static void fmt_mmss(char *b,size_t n,int sec){
  if(sec<0) sec=0;
  snprintf(b,n,"%2d:%02d",sec/60,sec%60);
}
static void fmt_dist(char *b,size_t n,const Arrival *a){
  b[0]='\0';
  if(a->dist_m>=0.0){
    double miles=a->dist_m/1609.344;
    if(miles<10.0) snprintf(b,n,"%.1f miles",miles);
    else snprintf(b,n,"%.0f miles",miles);
    return;
  }
  if(a->presentable[0]) snprintf(b,n,"%s",a->presentable);
}

/* ---- main ---- */
int main(void){
  signal(SIGINT,on_sig);
  signal(SIGTERM,on_sig);

  fprintf(stderr, "BUILD_TAG=%s\n", BUILD_TAG);

  const char *key=getenv("MTA_KEY");
  if(!key || !*key){ fprintf(stderr,"ERROR: MTA_KEY is not set\n"); return 2; }
  const char *stop=getenv("STOP_ID"); if(!stop||!*stop) stop="501627";

  int poll_s=env_int("POLL_SECONDS",10); if(poll_s<3) poll_s=3;
  int window_min=env_int("WINDOW_MINUTES",30); if(window_min<5) window_min=5;
  int max_show=env_int("MAX_SHOW",12); if(max_show<4) max_show=4; if(max_show>24) max_show=24;

  const char *sound_new=getenv("SOUND_NEW");
  const char *sound_arr=getenv("SOUND_ARRIVE");

  if(SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER)!=0){ fprintf(stderr,"SDL_Init failed: %s\n",SDL_GetError()); return 3; }
  if(TTF_Init()!=0){ fprintf(stderr,"TTF_Init failed: %s\n",TTF_GetError()); return 3; }

  SDL_ShowCursor(SDL_DISABLE);
  SDL_Window *win=SDL_CreateWindow("Arrival Board",SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,1280,720,SDL_WINDOW_FULLSCREEN_DESKTOP);
  if(!win){ fprintf(stderr,"SDL_CreateWindow failed: %s\n",SDL_GetError()); return 3; }

  SDL_Renderer *ren=SDL_CreateRenderer(win,-1,SDL_RENDERER_ACCELERATED|SDL_RENDERER_PRESENTVSYNC);
  if(!ren) ren=SDL_CreateRenderer(win,-1,SDL_RENDERER_SOFTWARE);
  if(!ren){ fprintf(stderr,"SDL_CreateRenderer failed: %s\n",SDL_GetError()); return 3; }

  int W=0,H=0; SDL_GetRendererOutputSize(ren,&W,&H);
  SDL_RendererInfo ri; memset(&ri,0,sizeof(ri)); SDL_GetRendererInfo(ren,&ri);

  fprintf(stderr,"Renderer size %dx%d\n",W,H);
  fprintf(stderr,"Renderer: %s maxTex=%dx%d\n", ri.name?ri.name:"(unknown)", ri.max_texture_width, ri.max_texture_height);

  const char *font_reg="/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf";
  const char *font_bld="/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf";

  int title_px=(int)fmax(26.0, H*0.020);
  int route_px=(int)fmax(24.0, H*0.018);
  int body_px =(int)fmax(18.0, H*0.015);
  int small_px=(int)fmax(16.0, H*0.013);
  int eta_px  =(int)fmax(30.0, H*0.028);

  fprintf(stderr,"Font px: title=%d route=%d body=%d small=%d eta=%d\n", title_px,route_px,body_px,small_px,eta_px);

  TTF_Font *f_title=TTF_OpenFont(font_bld,title_px);
  TTF_Font *f_route=TTF_OpenFont(font_bld,route_px);
  TTF_Font *f_body =TTF_OpenFont(font_reg,body_px);
  TTF_Font *f_small=TTF_OpenFont(font_reg,small_px);
  TTF_Font *f_eta  =TTF_OpenFont(font_bld,eta_px);

  if(!f_title||!f_route||!f_body||!f_small||!f_eta){
    fprintf(stderr,"TTF_OpenFont failed: %s\n", TTF_GetError());
    return 3;
  }

  curl_global_init(CURL_GLOBAL_DEFAULT);

  // primitive “seen” arrays for beeps
  typedef struct { char k[128]; int eta; } Seen;
  Seen prev[256]; int prev_n=0;

  char last_stop_name[128]={0};

  while(!g_quit){
    char url[512];
    snprintf(url,sizeof(url),
      "https://bustime.mta.info/api/siri/stop-monitoring.json"
      "?key=%s&version=2&OperatorRef=MTA&MonitoringRef=%s"
      "&MaximumStopVisits=60&StopMonitoringDetailLevel=normal",
      key, stop);

    long code=0;
    char *resp=http_get(url,&code);

    ArrivalList all; list_init(&all);
    time_t now=time(NULL);

    if(!resp || code!=200 || !parse_arrivals(resp,&all)){
      SDL_SetRenderDrawColor(ren,0,0,0,255);
      SDL_RenderClear(ren);
      SDL_Color w={255,255,255,255};
      char line[256]; snprintf(line,sizeof(line),"BusTime API error (HTTP %ld)",code);
      draw_fit(ren,ri.max_texture_width,f_title,60,60,W-120,w,line);
      SDL_RenderPresent(ren);
      free(resp);
      list_free(&all);
      for(int i=0;i<poll_s*10 && !g_quit;i++) SDL_Delay(100);
      continue;
    }

    for(int i=0;i<all.n;i++){
      if(all.a[i].stop_name[0]){ safe_copy(last_stop_name,sizeof(last_stop_name),all.a[i].stop_name); break; }
    }

    ArrivalList filt; list_init(&filt);
    int window_s=window_min*60;

    for(int i=0;i<all.n;i++){
      Arrival *a=&all.a[i];
      time_t t=a->has_expected?a->expected:a->aimed;
      int eta=(int)difftime(t,now);
      if(eta<-120) continue;
      if(eta>window_s) continue;
      list_push(&filt,a);
    }
    list_free(&all);

    qsort(filt.a,(size_t)filt.n,sizeof(Arrival),cmp_arr);
    int show=filt.n; if(show>max_show) show=max_show;

    // beeps: new bus appears + bus crosses <=60s
    for(int i=0;i<show;i++){
      Arrival *a=&filt.a[i];
      time_t t=a->has_expected?a->expected:a->aimed;
      int eta=(int)difftime(t,now);

      char kbuf[128];
      snprintf(kbuf,sizeof(kbuf),"%s|%s",a->route,a->vehicle[0]?a->vehicle:"?");

      int prev_i=-1;
      for(int p=0;p<prev_n;p++){ if(strcasecmp(prev[p].k,kbuf)==0){ prev_i=p; break; } }

      if(sound_new && *sound_new){
        if(prev_i<0) play_wav_async(sound_new);
      }
      if(sound_arr && *sound_arr){
        if(prev_i>=0){
          if(prev[prev_i].eta>60 && eta<=60) play_wav_async(sound_arr);
        }
      }
    }
    // refresh prev list with current items
    prev_n=0;
    for(int i=0;i<show && prev_n<256;i++){
      Arrival *a=&filt.a[i];
      time_t t=a->has_expected?a->expected:a->aimed;
      int eta=(int)difftime(t,now);
      snprintf(prev[prev_n].k,sizeof(prev[prev_n].k),"%s|%s",a->route,a->vehicle[0]?a->vehicle:"?");
      prev[prev_n].eta=eta;
      prev_n++;
    }

    // ---- render ----
    SDL_SetRenderDrawColor(ren,0,0,0,255);
    SDL_RenderClear(ren);

    SDL_Color white={255,255,255,255};
    SDL_Color gray ={180,180,180,255};

    int margin=(int)fmax(30.0, W*0.012);
    int header_y=margin;

    char title[256];
    if(last_stop_name[0]) snprintf(title,sizeof(title),"%s",last_stop_name);
    else snprintf(title,sizeof(title),"Stop %s",stop);

    char hhmmss[32]; fmt_hms(hhmmss,sizeof(hhmmss),time(NULL));
    char updated[64]; snprintf(updated,sizeof(updated),"Updated %s",hhmmss);

    draw_fit(ren,ri.max_texture_width,f_title,margin,header_y,(int)(W*0.70),white,title);

    int upd_w=text_w(f_small,updated);
    draw_fit(ren,ri.max_texture_width,f_small,W-margin-upd_w,header_y + (TTF_FontHeight(f_title)-TTF_FontHeight(f_small)), upd_w+10, gray, updated);

    char sub[128]; snprintf(sub,sizeof(sub),"Next %d minutes • showing %d • %s",window_min,show,BUILD_TAG);
    int sub_y=header_y + TTF_FontHeight(f_title) + (int)fmax(6.0,H*0.004);
    draw_fit(ren,ri.max_texture_width,f_small,margin,sub_y,W-2*margin,gray,sub);

    int grid_y=sub_y + TTF_FontHeight(f_small) + (int)fmax(10.0,H*0.006);

    int cols=2;
    int rows=(max_show+cols-1)/cols;
    if(max_show==12) rows=6;
    int gap_x=(int)fmax(22.0, W*0.010);
    int col_w=(W - 2*margin - gap_x)/cols;

    int pad=(int)fmax(8.0, H*0.004);
    int sp =(int)fmax(4.0, H*0.002);

    int need_h = pad + TTF_FontHeight(f_route) + sp + TTF_FontHeight(f_body) + sp + TTF_FontHeight(f_small) + pad;
    int avail_h = (H - margin - grid_y);
    int row_h = avail_h / rows;
    if(row_h > need_h) row_h = need_h;
    if(row_h < need_h - 10) row_h = need_h;

    if(show==0){
      draw_fit(ren,ri.max_texture_width,f_body,margin,grid_y+20,W-2*margin,white,"No buses due in the next window.");
    }

    for(int i=0;i<show;i++){
      int c=i%cols, rr=i/cols;
      int x0=margin + c*(col_w + gap_x);
      int y0=grid_y + rr*row_h;

      SDL_Rect tile={x0,y0,col_w,row_h-2};
      SDL_SetRenderDrawColor(ren,18,18,22,255);
      SDL_RenderFillRect(ren,&tile);
      SDL_SetRenderDrawColor(ren,55,55,70,255);
      SDL_RenderDrawRect(ren,&tile);

      Arrival *a=&filt.a[i];
      time_t t=a->has_expected?a->expected:a->aimed;
      int eta=(int)difftime(t,now);

      char eta_s[32]; fmt_mmss(eta_s,sizeof(eta_s),eta);
      int eta_w=text_w(f_eta,eta_s);
      int eta_x=x0 + col_w - pad - eta_w;

      int line1_y=y0 + pad;
      draw_fit(ren,ri.max_texture_width,f_route,x0+pad,line1_y,eta_x-(x0+pad)-10,white,a->route[0]?a->route:"?");
      draw_fit(ren,ri.max_texture_width,f_eta,eta_x,line1_y-2,col_w-(eta_x-x0),white,eta_s);

      int line2_y=line1_y + TTF_FontHeight(f_route) + sp;
      draw_fit(ren,ri.max_texture_width,f_body,x0+pad,line2_y,col_w-2*pad,gray,a->dest);

      char vshort[64];
      if(a->vehicle[0]){
        const char *vv=a->vehicle; size_t L=strlen(vv);
        if(L>4) vv=vv+(L-4);
        snprintf(vshort,sizeof(vshort),"Bus %s",vv);
      } else snprintf(vshort,sizeof(vshort),"Bus ?");

      char dist[96]; fmt_dist(dist,sizeof(dist),a);

      char info[256];
      if(dist[0] && a->progress[0]) snprintf(info,sizeof(info),"%s - %s - %s",vshort,dist,a->progress);
      else if(dist[0]) snprintf(info,sizeof(info),"%s - %s",vshort,dist);
      else if(a->progress[0]) snprintf(info,sizeof(info),"%s - %s",vshort,a->progress);
      else snprintf(info,sizeof(info),"%s",vshort);

      int line3_y=line2_y + TTF_FontHeight(f_body) + sp;
      draw_fit(ren,ri.max_texture_width,f_small,x0+pad,line3_y,col_w-2*pad,white,info);
    }

    SDL_RenderPresent(ren);

    free(resp);
    list_free(&filt);

    for(int i=0;i<poll_s*10 && !g_quit;i++) SDL_Delay(100);
  }

  curl_global_cleanup();
  return 0;
}
