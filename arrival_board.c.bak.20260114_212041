#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <curl/curl.h>
#include <cjson/cJSON.h>

#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <signal.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/wait.h>

#define BUILD_TAG "AB_REGEN_2026-01-14_4COL_12"

static volatile sig_atomic_t g_quit = 0;
static void on_sig(int s){ (void)s; g_quit = 1; }

static const char* env_str(const char *k, const char *defv){
  const char *v = getenv(k);
  return (v && *v) ? v : defv;
}
static int env_int(const char *k, int defv){
  const char *v = getenv(k);
  if(!v || !*v) return defv;
  char *e=NULL; long n=strtol(v,&e,10);
  if(e==v) return defv;
  return (int)n;
}

static void log_msg(const char *fmt, ...){
  va_list ap; va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  fflush(stderr);
  va_end(ap);
}

/* ---------- time parsing ---------- */

static time_t timegm_fallback(struct tm *tmv){
#if defined(__GLIBC__) || defined(_GNU_SOURCE)
  return timegm(tmv);
#else
  /* Portable-ish fallback: temporarily force TZ=UTC for mktime() */
  char *old = getenv("TZ");
  char oldbuf[128]; oldbuf[0]=0;
  if(old) snprintf(oldbuf, sizeof(oldbuf), "%s", old);
  setenv("TZ", "UTC", 1);
  tzset();
  time_t t = mktime(tmv);
  if(old) setenv("TZ", oldbuf, 1); else unsetenv("TZ");
  tzset();
  return t;
#endif
}

/* Parse ISO8601 like: 2026-01-14T18:34:08.207-05:00 */
static bool iso8601_to_epoch(const char *s, time_t *out){
  if(!s || !*s) return false;

  int Y=0,M=0,D=0,h=0,m=0;
  double secf=0.0;

  /* First parse date/time (ignore fractional for now) */
  /* We will parse seconds as double to allow .mmm */
  int n = sscanf(s, "%d-%d-%dT%d:%d:%lf", &Y,&M,&D,&h,&m,&secf);
  if(n < 6) return false;

  int sec = (int)floor(secf + 1e-9);

  /* Find timezone offset part: last '+' or '-' after the time */
  const char *tz = NULL;
  for(const char *p = s; *p; p++){
    if((*p=='+' || *p=='-') && p > s){
      /* ensure it's part of TZ, not date */
      if(p[1] && isdigit((unsigned char)p[1])) tz = p;
    }
  }

  int off_sign = 1;
  int off_h=0, off_m=0;
  int off_sec = 0;

  if(tz){
    off_sign = (*tz=='-') ? -1 : 1;
    if(sscanf(tz+1, "%d:%d", &off_h, &off_m) == 2){
      off_sec = off_sign * (off_h*3600 + off_m*60);
    }
  } else {
    /* If no TZ is present, assume local time; treat as already-local (no offset correction). */
    off_sec = 0;
  }

  struct tm tmv;
  memset(&tmv, 0, sizeof(tmv));
  tmv.tm_year = Y - 1900;
  tmv.tm_mon  = M - 1;
  tmv.tm_mday = D;
  tmv.tm_hour = h;
  tmv.tm_min  = m;
  tmv.tm_sec  = sec;
  tmv.tm_isdst = -1;

  /* Interpret the Y-M-D h:m:s as UTC, then correct by offset to get true UTC epoch */
  time_t t0 = timegm_fallback(&tmv);
  if(t0 == (time_t)-1) return false;

  /* Example: "18:34 -05:00" => off_sec=-18000 => epoch = t0 - (-18000) => add 5 hours */
  time_t epoch = t0 - off_sec;
  *out = epoch;
  return true;
}

/* ---------- curl fetch ---------- */

struct MemBuf {
  char *p;
  size_t n;
};

static size_t curl_write_cb(void *ptr, size_t sz, size_t nm, void *ud){
  size_t bytes = sz * nm;
  struct MemBuf *mb = (struct MemBuf*)ud;
  char *np = (char*)realloc(mb->p, mb->n + bytes + 1);
  if(!np) return 0;
  mb->p = np;
  memcpy(mb->p + mb->n, ptr, bytes);
  mb->n += bytes;
  mb->p[mb->n] = '\0';
  return bytes;
}

static bool fetch_stop_json(const char *key, const char *stop_id, int max_visits, char **out_body, long *out_http){
  *out_body = NULL;
  if(out_http) *out_http = 0;

  char url[1024];
  snprintf(url, sizeof(url),
    "https://bustime.mta.info/api/siri/stop-monitoring.json"
    "?key=%s&version=2&OperatorRef=MTA&MonitoringRef=%s&MaximumStopVisits=%d&StopMonitoringDetailLevel=normal",
    key, stop_id, max_visits);

  CURL *curl = curl_easy_init();
  if(!curl){
    log_msg("ERROR: curl_easy_init failed");
    return false;
  }

  struct MemBuf mb; mb.p = NULL; mb.n = 0;

  curl_easy_setopt(curl, CURLOPT_URL, url);
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
  curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);
  curl_easy_setopt(curl, CURLOPT_USERAGENT, "arrival_board/1.0");
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_cb);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, &mb);

  CURLcode rc = curl_easy_perform(curl);
  long http = 0;
  curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http);
  curl_easy_cleanup(curl);

  if(out_http) *out_http = http;

  if(rc != CURLE_OK){
    log_msg("FETCH stop=%s curl error: %s", stop_id, curl_easy_strerror(rc));
    free(mb.p);
    return false;
  }
  if(http != 200){
    log_msg("FETCH stop=%s HTTP %ld bytes=%zu", stop_id, http, mb.n);
    free(mb.p);
    return false;
  }

  *out_body = mb.p;
  return true;
}

/* ---------- parsing ---------- */

typedef struct Arrival {
  char route[16];
  char veh[32];
  char dest[80];
  char stop_name[80];
  char prox[64];      /* e.g. "0.6 miles away" or "1 stop away" */
  int  dist_m;        /* DistanceFromStop meters */
  int  stops_away;    /* NumberOfStopsAway */
  time_t eta_epoch;
  int eta_sec;
  bool realtime;      /* ExpectedArrivalTime used */
} Arrival;

static int cmp_arrival(const void *a, const void *b){
  const Arrival *A = (const Arrival*)a;
  const Arrival *B = (const Arrival*)b;
  if(A->eta_epoch < B->eta_epoch) return -1;
  if(A->eta_epoch > B->eta_epoch) return 1;
  return 0;
}

static void trim_route(char *dst, size_t dstsz, const char *src){
  /* Prefer simple route name: if "MTA NYCT_Q27" -> "Q27" */
  if(!src) { snprintf(dst, dstsz, "?"); return; }
  const char *p = strrchr(src, '_');
  if(p && p[1]) snprintf(dst, dstsz, "%s", p+1);
  else snprintf(dst, dstsz, "%s", src);
}

static void trim_vehicle(char *dst, size_t dstsz, const char *src){
  /* if "MTA NYCT_8838" -> "8838" */
  if(!src) { dst[0]=0; return; }
  const char *p = strrchr(src, '_');
  if(p && p[1]) snprintf(dst, dstsz, "%s", p+1);
  else snprintf(dst, dstsz, "%s", src);
}

static const cJSON* jget(const cJSON *o, const char *k){
  if(!o || !k) return NULL;
  return cJSON_GetObjectItemCaseSensitive((cJSON*)o, k);
}
static const char* jstr0(const cJSON *o, const char *k){
  const cJSON *v = jget(o,k);
  return (v && cJSON_IsString(v) && v->valuestring) ? v->valuestring : NULL;
}
static int jint0(const cJSON *o, const char *k, int defv){
  const cJSON *v = jget(o,k);
  if(v && cJSON_IsNumber(v)) return (int)llround(v->valuedouble);
  return defv;
}

static const char* jarr_str0(const cJSON *o, const char *k){
  const cJSON *a = jget(o,k);
  if(a && cJSON_IsArray(a)){
    const cJSON *x = cJSON_GetArrayItem((cJSON*)a, 0);
    if(x && cJSON_IsString(x) && x->valuestring) return x->valuestring;
  }
  return NULL;
}

static int parse_arrivals(const char *json,
                          Arrival **out_arr, int *out_n,
                          char *out_stopname, size_t out_stopname_sz,
                          const char *stop_ref,
                          const char *route_filter,
                          int lookahead_sec,
                          time_t now_epoch,
                          int max_out)
{
  *out_arr = NULL;
  *out_n = 0;
  if(out_stopname && out_stopname_sz) out_stopname[0]=0;

  cJSON *root = cJSON_Parse(json);
  if(!root){
    log_msg("PARSE: cJSON_Parse failed");
    return 0;
  }

  const cJSON *Siri = jget(root,"Siri");
  const cJSON *SD   = Siri ? jget(Siri,"ServiceDelivery") : NULL;
  const cJSON *SMD  = SD ? jget(SD,"StopMonitoringDelivery") : NULL;
  const cJSON *SMD0 = (SMD && cJSON_IsArray(SMD)) ? cJSON_GetArrayItem((cJSON*)SMD, 0) : NULL;
  const cJSON *MSV  = SMD0 ? jget(SMD0,"MonitoredStopVisit") : NULL;

  if(!MSV || !cJSON_IsArray(MSV)){
    cJSON_Delete(root);
    return 0;
  }

  int cap = 32;
  Arrival *arr = (Arrival*)calloc((size_t)cap, sizeof(Arrival));
  int n = 0;

  int msv_n = cJSON_GetArraySize((cJSON*)MSV);
  for(int i=0; i<msv_n; i++){
    const cJSON *v = cJSON_GetArrayItem((cJSON*)MSV, i);
    if(!v) continue;

    const cJSON *mj = jget(v, "MonitoredVehicleJourney");
    if(!mj) continue;

    const cJSON *mc = jget(mj, "MonitoredCall");
    if(!mc) continue;

    const char *mc_stop = jstr0(mc, "StopPointRef");
    if(!mc_stop || strcmp(mc_stop, stop_ref) != 0){
      continue;
    }

    const char *rtname = jarr_str0(mj, "PublishedLineName");
    if(!rtname) rtname = jstr0(mj, "LineRef");

    char route_simple[16];
    trim_route(route_simple, sizeof(route_simple), rtname);

    if(route_filter && *route_filter){
      /* allow "Q27" or "MTA NYCT_Q27" style */
      if(strcasecmp(route_filter, route_simple)!=0 && (rtname && strcasecmp(route_filter, rtname)!=0)){
        continue;
      }
    }

    const char *vehref = jstr0(mj, "VehicleRef");
    const char *dest0  = jarr_str0(mj, "DestinationName");
    const char *stopnm = jarr_str0(mc, "StopPointName");

    const char *expected = jstr0(mc, "ExpectedArrivalTime");
    const char *aimed    = jstr0(mc, "AimedArrivalTime");
    bool realtime = (expected && *expected);

    const char *tstr = (expected && *expected) ? expected : aimed;
    if(!tstr || !*tstr) continue;

    time_t eta = 0;
    if(!iso8601_to_epoch(tstr, &eta)) continue;

    int eta_sec = (int)difftime(eta, now_epoch);

    /* drop clearly past entries */
    if(eta_sec < -120) continue;

    /* lookahead */
    if(lookahead_sec > 0 && eta_sec > lookahead_sec) continue;

    if(n >= max_out) continue;

    if(n >= cap){
      cap *= 2;
      Arrival *na = (Arrival*)realloc(arr, (size_t)cap * sizeof(Arrival));
      if(!na) break;
      arr = na;
      memset(arr + n, 0, (size_t)(cap - n) * sizeof(Arrival));
    }

    Arrival *A = &arr[n++];
    snprintf(A->route, sizeof(A->route), "%s", route_simple);
    trim_vehicle(A->veh, sizeof(A->veh), vehref ? vehref : "");
    snprintf(A->dest, sizeof(A->dest), "%s", dest0 ? dest0 : "");
    snprintf(A->stop_name, sizeof(A->stop_name), "%s", stopnm ? stopnm : "");
    snprintf(A->prox, sizeof(A->prox), "%s", jstr0(mc, "ArrivalProximityText") ? jstr0(mc, "ArrivalProximityText") : "");
    A->dist_m = jint0(mc, "DistanceFromStop", -1);
    A->stops_away = jint0(mc, "NumberOfStopsAway", -1);
    A->eta_epoch = eta;
    A->eta_sec = eta_sec;
    A->realtime = realtime;

    if(out_stopname && out_stopname_sz && (!out_stopname[0]) && stopnm && *stopnm){
      snprintf(out_stopname, out_stopname_sz, "%s", stopnm);
    }
  }

  qsort(arr, (size_t)n, sizeof(Arrival), cmp_arrival);

  cJSON_Delete(root);

  *out_arr = arr;
  *out_n = n;
  return n;
}

/* ---------- sound (aplay) ---------- */

static void play_aplay(const char *device, const char *wav){
  if(!wav || !*wav) return;
  pid_t pid = fork();
  if(pid == 0){
    /* child */
    if(device && *device){
      execlp("aplay", "aplay", "-q", "-D", device, wav, (char*)NULL);
    } else {
      execlp("aplay", "aplay", "-q", wav, (char*)NULL);
    }
    _exit(127);
  }
}

/* ---------- text rendering ---------- */

typedef struct Tex {
  SDL_Texture *t;
  int w,h;
} Tex;

static Tex make_text(SDL_Renderer *r, TTF_Font *f, SDL_Color c, const char *s, bool solid){
  Tex x; x.t=NULL; x.w=0; x.h=0;
  if(!s) s="";
  SDL_Surface *surf = solid ? TTF_RenderUTF8_Solid(f, s, c)
                            : TTF_RenderUTF8_Blended(f, s, c);
  if(!surf) return x;
  SDL_Texture *t = SDL_CreateTextureFromSurface(r, surf);
  x.w = surf->w; x.h = surf->h;
  SDL_FreeSurface(surf);
  x.t = t;
  return x;
}
static void draw_tex(SDL_Renderer *r, Tex x, int x0, int y0){
  if(!x.t) return;
  SDL_Rect dst = { x0, y0, x.w, x.h };
  SDL_RenderCopy(r, x.t, NULL, &dst);
}
static void free_tex(Tex *x){
  if(x && x->t){ SDL_DestroyTexture(x->t); x->t=NULL; }
}

/* ---------- formatting ---------- */

static void fmt_eta(char *buf, size_t bufsz, int eta_sec){
  if(eta_sec < 0) eta_sec = 0;
  int min = eta_sec / 60;
  if(min <= 0) snprintf(buf, bufsz, "NOW");
  else snprintf(buf, bufsz, "%d", min);
}

static void fmt_dist_stops(char *buf, size_t bufsz, const Arrival *a){
  buf[0]=0;

  /* Prefer MTA's own proximity text if it already includes miles/stops wording */
  if(a->prox[0]){
    /* Just use it (already says "miles away" or "stop(s) away") */
    snprintf(buf, bufsz, "%s", a->prox);
    return;
  }

  /* Fallback: build from numeric fields */
  if(a->stops_away >= 0 && a->dist_m >= 0){
    double miles = a->dist_m / 1609.344;
    snprintf(buf, bufsz, "%d stop%s • %.1f miles",
             a->stops_away, (a->stops_away==1?"":"s"), miles);
    return;
  }
  if(a->dist_m >= 0){
    double miles = a->dist_m / 1609.344;
    snprintf(buf, bufsz, "%.1f miles away", miles);
    return;
  }
  if(a->stops_away >= 0){
    snprintf(buf, bufsz, "%d stop%s away", a->stops_away, (a->stops_away==1?"":"s"));
    return;
  }
}

/* ---------- main ---------- */

int main(int argc, char **argv){
  (void)argc; (void)argv;

  signal(SIGINT, on_sig);
  signal(SIGTERM, on_sig);

  const char *key = getenv("MTA_KEY");
  if(!key || !*key){
    log_msg("ERROR: MTA_KEY is not set in environment.");
    return 1;
  }

  const char *stop_id = env_str("STOP_ID", "501627");
  const char *route_filter = env_str("ROUTE_FILTER", "");
  int poll_sec = env_int("POLL_SECONDS", 10);
  int max_buses = env_int("MAX_BUSES", 12);
  int lookahead_min = env_int("LOOKAHEAD_MIN", 180);
  int lookahead_sec = lookahead_min * 60;

  const char *font_path = env_str("FONT_PATH", "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf");
  const char *ttf_mode = env_str("TTF_MODE", "solid"); /* solid or blended */
  bool solid = (strcasecmp(ttf_mode, "solid") == 0);

  const char *aplay_dev = env_str("APLAY_DEVICE", "");
  const char *snd_new = env_str("SOUND_NEW", "");
  const char *snd_arrive = env_str("SOUND_ARRIVE", "");

  char stop_ref[64];
  snprintf(stop_ref, sizeof(stop_ref), "MTA_%s", stop_id);

  if(curl_global_init(CURL_GLOBAL_DEFAULT) != 0){
    log_msg("ERROR: curl_global_init failed");
    return 1;
  }

  if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0){
    log_msg("ERROR: SDL_Init: %s", SDL_GetError());
    curl_global_cleanup();
    return 1;
  }
  if(TTF_Init() != 0){
    log_msg("ERROR: TTF_Init: %s", TTF_GetError());
    SDL_Quit();
    curl_global_cleanup();
    return 1;
  }

  /* Fullscreen desktop window (fixes the tiny grey window issue) */
  SDL_Window *win = SDL_CreateWindow(
    "Arrival Board",
    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
    1280, 720,
    SDL_WINDOW_SHOWN | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_FULLSCREEN_DESKTOP
  );
  if(!win){
    log_msg("ERROR: SDL_CreateWindow: %s", SDL_GetError());
    TTF_Quit(); SDL_Quit(); curl_global_cleanup();
    return 1;
  }

  SDL_Renderer *ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
  if(!ren){
    ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_SOFTWARE);
  }
  if(!ren){
    log_msg("ERROR: SDL_CreateRenderer: %s", SDL_GetError());
    SDL_DestroyWindow(win);
    TTF_Quit(); SDL_Quit(); curl_global_cleanup();
    return 1;
  }

  int rw=0, rh=0;
  SDL_GetRendererOutputSize(ren, &rw, &rh);
  log_msg("BUILD_TAG=%s", BUILD_TAG);
  log_msg("Renderer size %dx%d", rw, rh);

  /* Font sizing tuned for TV at 1080p/4K */
  int title_px = (rh >= 2000) ? 50 : 36;
  int body_px  = (rh >= 2000) ? 34 : 24;
  int small_px = (rh >= 2000) ? 28 : 20;
  int eta_px   = (rh >= 2000) ? 70 : 48;
  int route_px = (rh >= 2000) ? 40 : 28;

  TTF_Font *f_title = TTF_OpenFont(font_path, title_px);
  TTF_Font *f_route = TTF_OpenFont(font_path, route_px);
  TTF_Font *f_body  = TTF_OpenFont(font_path, body_px);
  TTF_Font *f_small = TTF_OpenFont(font_path, small_px);
  TTF_Font *f_eta   = TTF_OpenFont(font_path, eta_px);

  if(!f_title || !f_route || !f_body || !f_small || !f_eta){
    log_msg("ERROR: TTF_OpenFont('%s') failed: %s", font_path, TTF_GetError());
    if(f_title) TTF_CloseFont(f_title);
    if(f_route) TTF_CloseFont(f_route);
    if(f_body)  TTF_CloseFont(f_body);
    if(f_small) TTF_CloseFont(f_small);
    if(f_eta)   TTF_CloseFont(f_eta);
    SDL_DestroyRenderer(ren);
    SDL_DestroyWindow(win);
    TTF_Quit(); SDL_Quit(); curl_global_cleanup();
    return 1;
  }

  log_msg("Font px: title=%d route=%d body=%d small=%d eta=%d", title_px, route_px, body_px, small_px, eta_px);

  /* State */
  Arrival *arrivals = NULL;
  int arrivals_n = 0;

  char last_stop_name[80]; last_stop_name[0]=0;

  /* For sound: remember last vehicle IDs shown */
  char last_veh_ids[32][32];
  int last_veh_n = 0;
  bool arrived_beeped[32]; memset(arrived_beeped, 0, sizeof(arrived_beeped));

  Uint32 next_fetch_ms = 0;
  Uint32 last_clock_ms = 0;

  while(!g_quit){
    SDL_Event e;
    while(SDL_PollEvent(&e)){
      if(e.type == SDL_QUIT) g_quit = 1;
      if(e.type == SDL_KEYDOWN){
        if(e.key.keysym.sym == SDLK_ESCAPE) g_quit = 1;
      }
    }

    Uint32 now_ms = SDL_GetTicks();
    if(now_ms >= next_fetch_ms){
      time_t now_epoch = time(NULL);

      char *body = NULL;
      long http = 0;
      bool ok = fetch_stop_json(key, stop_id, 60, &body, &http);
      if(ok && body){
        log_msg("FETCH stop=%s HTTP %ld bytes=%zu", stop_id, http, strlen(body));

        Arrival *newarr = NULL;
        int newn = 0;
        char stopname[80]; stopname[0]=0;

        int kept = parse_arrivals(body, &newarr, &newn,
                                  stopname, sizeof(stopname),
                                  stop_ref, route_filter,
                                  lookahead_sec, now_epoch, max_buses);

        log_msg("PARSE: kept %d arrivals (lookahead=%d min, filter='%s')", kept, lookahead_min, route_filter);

        if(stopname[0]) snprintf(last_stop_name, sizeof(last_stop_name), "%s", stopname);

        free(body);

        /* swap */
        free(arrivals);
        arrivals = newarr;
        arrivals_n = newn;

        /* Sound: new vehicles + arrival soon */
        bool any_new = false;

        for(int i=0; i<arrivals_n && i<max_buses && i<32; i++){
          const char *vid = arrivals[i].veh;
          bool seen = false;
          for(int j=0; j<last_veh_n; j++){
            if(strcmp(last_veh_ids[j], vid)==0){ seen = true; break; }
          }
          if(!seen && vid && *vid){
            any_new = true;
          }
        }

        if(any_new && snd_new && *snd_new){
          play_aplay(aplay_dev, snd_new);
        }

        /* Reset and rebuild last veh set */
        last_veh_n = 0;
        memset(arrived_beeped, 0, sizeof(arrived_beeped));
        for(int i=0; i<arrivals_n && i<32; i++){
          snprintf(last_veh_ids[last_veh_n++], sizeof(last_veh_ids[0]), "%s", arrivals[i].veh);
        }
      }

      next_fetch_ms = now_ms + (Uint32)(poll_sec * 1000);
    }

    /* Update ETA seconds once per second for display */
    if(now_ms - last_clock_ms >= 1000){
      time_t now_epoch = time(NULL);
      for(int i=0; i<arrivals_n; i++){
        arrivals[i].eta_sec = (int)difftime(arrivals[i].eta_epoch, now_epoch);
      }

      /* arrival beep when <= 90 sec */
      for(int i=0; i<arrivals_n && i<32; i++){
        if(!arrived_beeped[i] && arrivals[i].eta_sec <= 90 && arrivals[i].eta_sec >= 0){
          if(snd_arrive && *snd_arrive) play_aplay(aplay_dev, snd_arrive);
          arrived_beeped[i] = true;
        }
      }

      last_clock_ms = now_ms;
    }

    /* ---------- render ---------- */
    SDL_SetRenderDrawColor(ren, 10, 12, 16, 255);
    SDL_RenderClear(ren);

    SDL_Color white = {240,240,240,255};
    SDL_Color soft  = {180,190,205,255};
    SDL_Color accent= { 70,140,255,255};
    SDL_Color black = {  0,  0,  0,255};

    /* Header area */
    int margin = (rw >= 3000) ? 40 : 24;
    int header_h = (rh >= 2000) ? 140 : 96;

    SDL_Rect hdr = { margin, margin, rw - 2*margin, header_h };
    SDL_SetRenderDrawColor(ren, 16, 22, 34, 255);
    SDL_RenderFillRect(ren, &hdr);

    char title[256];
    if(route_filter && *route_filter){
      snprintf(title, sizeof(title), "%s — Stop %s", route_filter, stop_id);
    } else if(arrivals_n > 0){
      snprintf(title, sizeof(title), "%s — Stop %s", arrivals[0].route, stop_id);
    } else {
      snprintf(title, sizeof(title), "Stop %s", stop_id);
    }

    time_t nowt = time(NULL);
    struct tm ltm;
    localtime_r(&nowt, &ltm);
    char timestr[64];
    strftime(timestr, sizeof(timestr), "%a %b %d  %I:%M:%S %p", &ltm);

    Tex t_title = make_text(ren, f_title, white, title, solid);
    Tex t_time  = make_text(ren, f_small, soft, timestr, solid);
    Tex t_stopn = make_text(ren, f_small, soft, (last_stop_name[0] ? last_stop_name : ""), solid);

    int tx = hdr.x + 18;
    int ty = hdr.y + 12;
    draw_tex(ren, t_title, tx, ty);
    draw_tex(ren, t_time, hdr.x + hdr.w - t_time.w - 18, ty + 6);
    if(t_stopn.t){
      draw_tex(ren, t_stopn, tx, ty + t_title.h + 6);
    }

    free_tex(&t_title);
    free_tex(&t_time);
    free_tex(&t_stopn);

    /* Grid layout */
    int grid_top = hdr.y + hdr.h + 18;
    int grid_h = rh - grid_top - margin;

    int nshow = arrivals_n;
    if(nshow > max_buses) nshow = max_buses;

    if(nshow <= 0){
      Tex msg = make_text(ren, f_body, soft, "No upcoming arrivals to display", solid);
      draw_tex(ren, msg, margin + 30, grid_top + 30);
      free_tex(&msg);
      SDL_RenderPresent(ren);
      SDL_Delay(16);
      continue;
    }

    /* Choose columns based on screen width (4K -> 4 columns for 12 tiles) */
    int cols = (rw >= 3000) ? 4 : (rw >= 1800 ? 3 : (rw >= 1200 ? 2 : 1));
    if(cols < 1) cols = 1;
    if(cols > nshow) cols = nshow;

    int rows = (nshow + cols - 1) / cols;
    if(rows < 1) rows = 1;

    int gap = (rw >= 3000) ? 22 : 14;
    int tile_w = (rw - 2*margin - (cols - 1)*gap) / cols;
    int tile_h = (grid_h - (rows - 1)*gap) / rows;

    /* Slightly tighten tiles (less dead space) */
    if(tile_h > 10) tile_h -= 6;

    for(int i=0; i<nshow; i++){
      int c = i % cols;
      int r = i / cols;

      int x0 = margin + c * (tile_w + gap);
      int y0 = grid_top + r * (tile_h + gap);

      SDL_Rect tile = { x0, y0, tile_w, tile_h };
      SDL_SetRenderDrawColor(ren, 20, 28, 44, 255);
      SDL_RenderFillRect(ren, &tile);

      /* Accent stripe */
      SDL_Rect stripe = { x0, y0, 10, tile_h };
      SDL_SetRenderDrawColor(ren, accent.r, accent.g, accent.b, 255);
      SDL_RenderFillRect(ren, &stripe);

      /* Text content */
      const Arrival *a = &arrivals[i];

      char eta_buf[16];
      fmt_eta(eta_buf, sizeof(eta_buf), a->eta_sec);

      char dist_buf[128];
      fmt_dist_stops(dist_buf, sizeof(dist_buf), a);

      /* Top line: Route + Vehicle */
      char top_buf[128];
      if(a->veh[0]) snprintf(top_buf, sizeof(top_buf), "%s  #%s", a->route, a->veh);
      else snprintf(top_buf, sizeof(top_buf), "%s", a->route);

      /* Destination */
      char dest_buf[128];
      if(a->dest[0]) snprintf(dest_buf, sizeof(dest_buf), "%s", a->dest);
      else dest_buf[0]=0;

      /* ETA big */
      SDL_Color eta_col = white;
      if(a->eta_sec <= 60) eta_col = (SDL_Color){255, 170, 60, 255};

      Tex t_top  = make_text(ren, f_route, white, top_buf, solid);
      Tex t_dest = make_text(ren, f_small, soft, dest_buf, solid);
      Tex t_dist = make_text(ren, f_small, soft, dist_buf, solid);

      /* Big ETA on right */
      Tex t_eta  = make_text(ren, f_eta, eta_col, eta_buf, solid);
      Tex t_eta_u= make_text(ren, f_small, soft, (strcmp(eta_buf,"NOW")==0 ? "" : "min"), solid);

      int pad = 18;
      int cx = x0 + 10 + pad;
      int cy = y0 + pad;

      draw_tex(ren, t_top, cx, cy);
      if(t_dest.t) draw_tex(ren, t_dest, cx, cy + t_top.h + 6);

      /* bottom info line */
      if(t_dist.t){
        int by = y0 + tile_h - pad - t_dist.h;
        draw_tex(ren, t_dist, cx, by);
      }

      /* ETA right aligned */
      int ex = x0 + tile_w - pad - t_eta.w;
      int ey = y0 + (tile_h/2) - (t_eta.h/2);
      draw_tex(ren, t_eta, ex, ey);
      if(t_eta_u.t){
        draw_tex(ren, t_eta_u, ex + t_eta.w - t_eta_u.w, ey + t_eta.h + 2);
      }

      free_tex(&t_top);
      free_tex(&t_dest);
      free_tex(&t_dist);
      free_tex(&t_eta);
      free_tex(&t_eta_u);

      /* border */
      SDL_SetRenderDrawColor(ren, 35, 45, 70, 255);
      SDL_RenderDrawRect(ren, &tile);
    }

    SDL_RenderPresent(ren);
    SDL_Delay(16);
  }

  free(arrivals);

  TTF_CloseFont(f_title);
  TTF_CloseFont(f_route);
  TTF_CloseFont(f_body);
  TTF_CloseFont(f_small);
  TTF_CloseFont(f_eta);

  SDL_DestroyRenderer(ren);
  SDL_DestroyWindow(win);

  TTF_Quit();
  SDL_Quit();
  curl_global_cleanup();
  return 0;
}
