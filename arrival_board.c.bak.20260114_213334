#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <curl/curl.h>
#include <cjson/cJSON.h>

#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <signal.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define BUILD_TAG "AB_REGEN_FULLSCREEN_BOUNDS_2026-01-14_5"

static volatile sig_atomic_t g_quit = 0;
static void on_sig(int s){ (void)s; g_quit = 1; }

static void log_msg(const char *fmt, ...){
  va_list ap; va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  fflush(stderr);
  va_end(ap);
}

static const char* env_str(const char *k, const char *defv){
  const char *v = getenv(k);
  return (v && *v) ? v : defv;
}
static int env_int(const char *k, int defv){
  const char *v = getenv(k);
  if(!v || !*v) return defv;
  char *e=NULL; long n=strtol(v,&e,10);
  if(e==v) return defv;
  return (int)n;
}

/* ---------- time parsing ---------- */

static time_t timegm_fallback(struct tm *tmv){
#if defined(__GLIBC__) || defined(_GNU_SOURCE)
  return timegm(tmv);
#else
  char *old = getenv("TZ");
  char oldbuf[128]; oldbuf[0]=0;
  if(old) snprintf(oldbuf, sizeof(oldbuf), "%s", old);
  setenv("TZ","UTC",1); tzset();
  time_t t = mktime(tmv);
  if(old) setenv("TZ", oldbuf, 1); else unsetenv("TZ");
  tzset();
  return t;
#endif
}

/* Parse ISO8601: 2026-01-14T18:34:08.207-05:00 */
static bool iso8601_to_epoch(const char *s, time_t *out){
  if(!s || !*s) return false;

  int Y=0,M=0,D=0,h=0,m=0;
  double secf=0.0;
  if(sscanf(s, "%d-%d-%dT%d:%d:%lf", &Y,&M,&D,&h,&m,&secf) < 6) return false;

  int sec = (int)floor(secf + 1e-9);

  const char *tz = NULL;
  for(const char *p=s; *p; p++){
    if((*p=='+' || *p=='-') && p>s && p[1] && isdigit((unsigned char)p[1])){
      tz = p;
    }
  }
  int off_sign=1, off_h=0, off_m=0;
  int off_sec=0;
  if(tz){
    off_sign = (*tz=='-') ? -1 : 1;
    if(sscanf(tz+1, "%d:%d", &off_h, &off_m)==2){
      off_sec = off_sign*(off_h*3600 + off_m*60);
    }
  }

  struct tm tmv; memset(&tmv,0,sizeof(tmv));
  tmv.tm_year = Y-1900;
  tmv.tm_mon  = M-1;
  tmv.tm_mday = D;
  tmv.tm_hour = h;
  tmv.tm_min  = m;
  tmv.tm_sec  = sec;
  tmv.tm_isdst = -1;

  time_t t0 = timegm_fallback(&tmv);
  if(t0==(time_t)-1) return false;

  *out = t0 - off_sec;
  return true;
}

/* ---------- curl fetch ---------- */

struct MemBuf { char *p; size_t n; };

static size_t curl_write_cb(void *ptr, size_t sz, size_t nm, void *ud){
  size_t bytes = sz*nm;
  struct MemBuf *mb = (struct MemBuf*)ud;
  char *np = (char*)realloc(mb->p, mb->n + bytes + 1);
  if(!np) return 0;
  mb->p = np;
  memcpy(mb->p + mb->n, ptr, bytes);
  mb->n += bytes;
  mb->p[mb->n] = '\0';
  return bytes;
}

static bool fetch_stop_json(const char *key, const char *stop_id, int max_visits, char **out_body, long *out_http){
  *out_body = NULL;
  if(out_http) *out_http = 0;

  char url[1024];
  snprintf(url, sizeof(url),
    "https://bustime.mta.info/api/siri/stop-monitoring.json"
    "?key=%s&version=2&OperatorRef=MTA&MonitoringRef=%s&MaximumStopVisits=%d&StopMonitoringDetailLevel=normal",
    key, stop_id, max_visits);

  CURL *curl = curl_easy_init();
  if(!curl){ log_msg("ERROR: curl_easy_init failed"); return false; }

  struct MemBuf mb; mb.p=NULL; mb.n=0;

  curl_easy_setopt(curl, CURLOPT_URL, url);
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
  curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);
  curl_easy_setopt(curl, CURLOPT_USERAGENT, "arrival_board/1.0");
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_cb);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, &mb);

  CURLcode rc = curl_easy_perform(curl);
  long http=0;
  curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http);
  curl_easy_cleanup(curl);
  if(out_http) *out_http = http;

  if(rc != CURLE_OK){
    log_msg("FETCH stop=%s curl error: %s", stop_id, curl_easy_strerror(rc));
    free(mb.p);
    return false;
  }
  if(http != 200){
    log_msg("FETCH stop=%s HTTP %ld bytes=%zu", stop_id, http, mb.n);
    free(mb.p);
    return false;
  }

  *out_body = mb.p;
  return true;
}

/* ---------- JSON helpers ---------- */

static const cJSON* jget(const cJSON *o, const char *k){
  if(!o || !k) return NULL;
  return cJSON_GetObjectItemCaseSensitive((cJSON*)o, k);
}
static const char* jstr0(const cJSON *o, const char *k){
  const cJSON *v=jget(o,k);
  return (v && cJSON_IsString(v) && v->valuestring) ? v->valuestring : NULL;
}
static int jint0(const cJSON *o, const char *k, int defv){
  const cJSON *v=jget(o,k);
  if(v && cJSON_IsNumber(v)) return (int)llround(v->valuedouble);
  return defv;
}
static const char* jarr_str0(const cJSON *o, const char *k){
  const cJSON *a=jget(o,k);
  if(a && cJSON_IsArray(a)){
    const cJSON *x=cJSON_GetArrayItem((cJSON*)a,0);
    if(x && cJSON_IsString(x) && x->valuestring) return x->valuestring;
  }
  return NULL;
}

static void trim_route(char *dst, size_t dstsz, const char *src){
  if(!src){ snprintf(dst,dstsz,"?"); return; }
  const char *p=strrchr(src,'_');
  if(p && p[1]) snprintf(dst,dstsz,"%s",p+1);
  else snprintf(dst,dstsz,"%s",src);
}
static void trim_vehicle(char *dst, size_t dstsz, const char *src){
  if(!src){ dst[0]=0; return; }
  const char *p=strrchr(src,'_');
  if(p && p[1]) snprintf(dst,dstsz,"%s",p+1);
  else snprintf(dst,dstsz,"%s",src);
}

/* ---------- arrivals ---------- */

typedef struct Arrival {
  char route[16];
  char veh[32];
  char dest[96];
  char stop_name[96];
  char prox[80];
  int  dist_m;
  int  stops_away;
  time_t eta_epoch;
  int eta_sec;
  bool realtime;
} Arrival;

static int cmp_arrival(const void *a, const void *b){
  const Arrival *A=(const Arrival*)a;
  const Arrival *B=(const Arrival*)b;
  if(A->eta_epoch < B->eta_epoch) return -1;
  if(A->eta_epoch > B->eta_epoch) return  1;
  return 0;
}

static int parse_arrivals(const char *json,
                          Arrival **out_arr, int *out_n,
                          char *out_stopname, size_t out_stopname_sz,
                          const char *stop_ref,
                          const char *route_filter,
                          int lookahead_sec,
                          time_t now_epoch,
                          int max_out)
{
  *out_arr=NULL; *out_n=0;
  if(out_stopname && out_stopname_sz) out_stopname[0]=0;

  cJSON *root=cJSON_Parse(json);
  if(!root){ log_msg("PARSE: cJSON_Parse failed"); return 0; }

  const cJSON *Siri=jget(root,"Siri");
  const cJSON *SD=Siri?jget(Siri,"ServiceDelivery"):NULL;
  const cJSON *SMD=SD?jget(SD,"StopMonitoringDelivery"):NULL;
  const cJSON *SMD0=(SMD && cJSON_IsArray(SMD))?cJSON_GetArrayItem((cJSON*)SMD,0):NULL;
  const cJSON *MSV=SMD0?jget(SMD0,"MonitoredStopVisit"):NULL;

  if(!MSV || !cJSON_IsArray(MSV)){ cJSON_Delete(root); return 0; }

  int cap=32, n=0;
  Arrival *arr=(Arrival*)calloc((size_t)cap,sizeof(Arrival));
  int msv_n=cJSON_GetArraySize((cJSON*)MSV);

  for(int i=0;i<msv_n;i++){
    const cJSON *v=cJSON_GetArrayItem((cJSON*)MSV,i);
    if(!v) continue;

    const cJSON *mj=jget(v,"MonitoredVehicleJourney");
    if(!mj) continue;

    const cJSON *mc=jget(mj,"MonitoredCall");
    if(!mc) continue;

    const char *mc_stop=jstr0(mc,"StopPointRef");
    if(!mc_stop || strcmp(mc_stop, stop_ref)!=0) continue;

    const char *rtname=jarr_str0(mj,"PublishedLineName");
    if(!rtname) rtname=jstr0(mj,"LineRef");

    char route_simple[16];
    trim_route(route_simple,sizeof(route_simple),rtname);

    if(route_filter && *route_filter){
      if(strcasecmp(route_filter, route_simple)!=0 && (rtname && strcasecmp(route_filter, rtname)!=0)){
        continue;
      }
    }

    const char *expected=jstr0(mc,"ExpectedArrivalTime");
    const char *aimed=jstr0(mc,"AimedArrivalTime");
    const char *tstr=(expected && *expected)?expected:aimed;
    if(!tstr || !*tstr) continue;

    time_t eta=0;
    if(!iso8601_to_epoch(tstr,&eta)) continue;

    int eta_sec=(int)difftime(eta, now_epoch);
    if(eta_sec < -120) continue;
    if(lookahead_sec>0 && eta_sec>lookahead_sec) continue;

    if(n>=max_out) continue;

    if(n>=cap){
      cap*=2;
      Arrival *na=(Arrival*)realloc(arr,(size_t)cap*sizeof(Arrival));
      if(!na) break;
      arr=na;
      memset(arr+n,0,(size_t)(cap-n)*sizeof(Arrival));
    }

    Arrival *A=&arr[n++];
    snprintf(A->route,sizeof(A->route),"%s",route_simple);
    trim_vehicle(A->veh,sizeof(A->veh), jstr0(mj,"VehicleRef")?jstr0(mj,"VehicleRef"):"");
    snprintf(A->dest,sizeof(A->dest),"%s", jarr_str0(mj,"DestinationName")?jarr_str0(mj,"DestinationName"):"");
    snprintf(A->stop_name,sizeof(A->stop_name),"%s", jarr_str0(mc,"StopPointName")?jarr_str0(mc,"StopPointName"):"");
    snprintf(A->prox,sizeof(A->prox),"%s", jstr0(mc,"ArrivalProximityText")?jstr0(mc,"ArrivalProximityText"):"");
    A->dist_m=jint0(mc,"DistanceFromStop",-1);
    A->stops_away=jint0(mc,"NumberOfStopsAway",-1);
    A->eta_epoch=eta;
    A->eta_sec=eta_sec;
    A->realtime=(expected && *expected);

    if(out_stopname && out_stopname_sz && !out_stopname[0] && A->stop_name[0]){
      snprintf(out_stopname,out_stopname_sz,"%s",A->stop_name);
    }
  }

  qsort(arr,(size_t)n,sizeof(Arrival),cmp_arrival);

  cJSON_Delete(root);
  *out_arr=arr;
  *out_n=n;
  return n;
}

/* ---------- sound ---------- */

static void play_aplay(const char *device, const char *wav){
  if(!wav || !*wav) return;
  pid_t pid=fork();
  if(pid==0){
    if(device && *device) execlp("aplay","aplay","-q","-D",device,wav,(char*)NULL);
    else execlp("aplay","aplay","-q",wav,(char*)NULL);
    _exit(127);
  }
}

/* ---------- text rendering ---------- */

typedef struct Tex { SDL_Texture *t; int w,h; } Tex;

static Tex make_text(SDL_Renderer *r, TTF_Font *f, SDL_Color c, const char *s, bool solid){
  Tex x={0};
  if(!s) s="";
  SDL_Surface *surf = solid ? TTF_RenderUTF8_Solid(f,s,c) : TTF_RenderUTF8_Blended(f,s,c);
  if(!surf) return x;
  x.t = SDL_CreateTextureFromSurface(r,surf);
  x.w = surf->w; x.h = surf->h;
  SDL_FreeSurface(surf);
  return x;
}
static void draw_tex(SDL_Renderer *r, Tex x, int x0, int y0){
  if(!x.t) return;
  SDL_Rect dst={x0,y0,x.w,x.h};
  SDL_RenderCopy(r,x.t,NULL,&dst);
}
static void free_tex(Tex *x){
  if(x && x->t){ SDL_DestroyTexture(x->t); x->t=NULL; }
}

static void fmt_eta(char *buf, size_t bufsz, int eta_sec){
  if(eta_sec < 0) eta_sec = 0;
  int min = eta_sec/60;
  if(min<=0) snprintf(buf,bufsz,"NOW");
  else snprintf(buf,bufsz,"%d",min);
}
static void fmt_dist_stops(char *buf, size_t bufsz, const Arrival *a){
  buf[0]=0;
  if(a->prox[0]){ snprintf(buf,bufsz,"%s",a->prox); return; }
  if(a->stops_away>=0 && a->dist_m>=0){
    double miles=a->dist_m/1609.344;
    snprintf(buf,bufsz,"%d stop%s • %.1f miles",
      a->stops_away,(a->stops_away==1?"":"s"),miles);
    return;
  }
  if(a->dist_m>=0){
    double miles=a->dist_m/1609.344;
    snprintf(buf,bufsz,"%.1f miles away",miles);
    return;
  }
  if(a->stops_away>=0){
    snprintf(buf,bufsz,"%d stop%s away",a->stops_away,(a->stops_away==1?"":"s"));
    return;
  }
}

/* ---------- fullscreen “bulletproof” window ---------- */

static void force_window_to_display(SDL_Window *win, int display_index){
  SDL_Rect b;
  if(SDL_GetDisplayBounds(display_index, &b) != 0){
    log_msg("WARN: SDL_GetDisplayBounds failed: %s", SDL_GetError());
    return;
  }
  log_msg("DisplayBounds[%d]=%dx%d+%d+%d", display_index, b.w, b.h, b.x, b.y);

  /* This works even if fullscreen hints are ignored */
  SDL_SetWindowBordered(win, SDL_FALSE);
  SDL_SetWindowResizable(win, SDL_FALSE);
  SDL_SetWindowPosition(win, b.x, b.y);
  SDL_SetWindowSize(win, b.w, b.h);
  SDL_RaiseWindow(win);

  /* Try fullscreen desktop; if WM ignores it, we still fill via size+borderless. */
  if(SDL_SetWindowFullscreen(win, SDL_WINDOW_FULLSCREEN_DESKTOP) != 0){
    log_msg("WARN: SDL_SetWindowFullscreen(DESKTOP) failed/ignored: %s", SDL_GetError());
    /* Try true fullscreen as a fallback */
    if(SDL_SetWindowFullscreen(win, SDL_WINDOW_FULLSCREEN) != 0){
      log_msg("WARN: SDL_SetWindowFullscreen(TRUE) also failed: %s", SDL_GetError());
    } else {
      log_msg("Fullscreen TRUE set.");
    }
  } else {
    log_msg("Fullscreen DESKTOP set.");
  }

  /* Re-apply bounds after fullscreen attempt (some drivers shrink it otherwise) */
  SDL_SetWindowPosition(win, b.x, b.y);
  SDL_SetWindowSize(win, b.w, b.h);
}

int main(int argc, char **argv){
  (void)argc; (void)argv;
  signal(SIGINT,on_sig);
  signal(SIGTERM,on_sig);

  const char *key=getenv("MTA_KEY");
  if(!key || !*key){
    log_msg("ERROR: MTA_KEY is not set in environment.");
    return 1;
  }

  const char *stop_id = env_str("STOP_ID","501627");
  const char *route_filter = env_str("ROUTE_FILTER","");
  int poll_sec = env_int("POLL_SECONDS",10);
  int max_buses = env_int("MAX_BUSES",12);
  int lookahead_min = env_int("LOOKAHEAD_MIN",180);
  int lookahead_sec = lookahead_min*60;

  const char *font_path = env_str("FONT_PATH","/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf");
  const char *ttf_mode = env_str("TTF_MODE","solid");
  bool solid = (strcasecmp(ttf_mode,"solid")==0);

  const char *aplay_dev = env_str("APLAY_DEVICE","");
  const char *snd_new = env_str("SOUND_NEW","");
  const char *snd_arrive = env_str("SOUND_ARRIVE","");

  char stop_ref[64];
  snprintf(stop_ref,sizeof(stop_ref),"MTA_%s",stop_id);

  if(curl_global_init(CURL_GLOBAL_DEFAULT)!=0){
    log_msg("ERROR: curl_global_init failed");
    return 1;
  }

  log_msg("BUILD_TAG=%s", BUILD_TAG);
  log_msg("SDL video driver (requested)=%s", env_str("SDL_VIDEODRIVER","(unset)"));

  if(SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER)!=0){
    log_msg("ERROR: SDL_Init: %s", SDL_GetError());
    curl_global_cleanup();
    return 1;
  }
  log_msg("SDL video driver (actual)=%s", SDL_GetCurrentVideoDriver());

  if(TTF_Init()!=0){
    log_msg("ERROR: TTF_Init: %s", TTF_GetError());
    SDL_Quit(); curl_global_cleanup();
    return 1;
  }

  SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0");
  SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1");

  /* Start as a plain borderless window; we will force it to display bounds. */
  SDL_Window *win = SDL_CreateWindow(
    "Arrival Board",
    SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
    1280, 720,
    SDL_WINDOW_SHOWN | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_BORDERLESS
  );
  if(!win){
    log_msg("ERROR: SDL_CreateWindow: %s", SDL_GetError());
    TTF_Quit(); SDL_Quit(); curl_global_cleanup();
    return 1;
  }

  /* Force to display 0 bounds + fullscreen attempts */
  force_window_to_display(win, 0);
  SDL_ShowCursor(SDL_DISABLE);

  SDL_Renderer *ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
  if(!ren){
    log_msg("WARN: accelerated renderer failed: %s", SDL_GetError());
    ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_SOFTWARE);
  }
  if(!ren){
    log_msg("ERROR: SDL_CreateRenderer: %s", SDL_GetError());
    SDL_DestroyWindow(win);
    TTF_Quit(); SDL_Quit(); curl_global_cleanup();
    return 1;
  }

  int rw=0,rh=0;
  SDL_GetRendererOutputSize(ren,&rw,&rh);
  log_msg("Renderer output size %dx%d", rw, rh);

  /* font sizes */
  int title_px = (rh>=2000)?50:36;
  int body_px  = (rh>=2000)?34:24;
  int small_px = (rh>=2000)?28:20;
  int eta_px   = (rh>=2000)?70:48;
  int route_px = (rh>=2000)?40:28;

  TTF_Font *f_title=TTF_OpenFont(font_path,title_px);
  TTF_Font *f_route=TTF_OpenFont(font_path,route_px);
  TTF_Font *f_body =TTF_OpenFont(font_path,body_px);
  TTF_Font *f_small=TTF_OpenFont(font_path,small_px);
  TTF_Font *f_eta  =TTF_OpenFont(font_path,eta_px);

  if(!f_title||!f_route||!f_body||!f_small||!f_eta){
    log_msg("ERROR: TTF_OpenFont('%s') failed: %s", font_path, TTF_GetError());
    if(f_title)TTF_CloseFont(f_title);
    if(f_route)TTF_CloseFont(f_route);
    if(f_body) TTF_CloseFont(f_body);
    if(f_small)TTF_CloseFont(f_small);
    if(f_eta)  TTF_CloseFont(f_eta);
    SDL_DestroyRenderer(ren);
    SDL_DestroyWindow(win);
    TTF_Quit(); SDL_Quit(); curl_global_cleanup();
    return 1;
  }
  log_msg("Font px: title=%d route=%d body=%d small=%d eta=%d", title_px, route_px, body_px, small_px, eta_px);

  Arrival *arrivals=NULL; int arrivals_n=0;
  char last_stop_name[96]; last_stop_name[0]=0;

  char last_veh_ids[32][32]; int last_veh_n=0;
  bool arrived_beeped[32]; memset(arrived_beeped,0,sizeof(arrived_beeped));

  Uint32 next_fetch_ms=0;
  Uint32 last_clock_ms=0;

  while(!g_quit){
    SDL_Event e;
    while(SDL_PollEvent(&e)){
      if(e.type==SDL_QUIT) g_quit=1;
      if(e.type==SDL_KEYDOWN && e.key.keysym.sym==SDLK_ESCAPE) g_quit=1;
    }

    Uint32 now_ms=SDL_GetTicks();

    if(now_ms>=next_fetch_ms){
      time_t now_epoch=time(NULL);
      char *body=NULL; long http=0;

      if(fetch_stop_json(key, stop_id, 60, &body, &http) && body){
        log_msg("FETCH stop=%s HTTP %ld bytes=%zu", stop_id, http, strlen(body));

        Arrival *newarr=NULL; int newn=0;
        char stopname[96]; stopname[0]=0;

        int kept=parse_arrivals(body,&newarr,&newn,stopname,sizeof(stopname),
                               stop_ref,route_filter,lookahead_sec,now_epoch,max_buses);
        log_msg("PARSE: kept %d arrivals (lookahead=%d min, filter='%s')", kept, lookahead_min, route_filter);

        if(stopname[0]) snprintf(last_stop_name,sizeof(last_stop_name),"%s",stopname);

        free(body);

        free(arrivals);
        arrivals=newarr; arrivals_n=newn;

        bool any_new=false;
        for(int i=0;i<arrivals_n && i<max_buses && i<32;i++){
          const char *vid=arrivals[i].veh;
          bool seen=false;
          for(int j=0;j<last_veh_n;j++){
            if(strcmp(last_veh_ids[j],vid)==0){ seen=true; break; }
          }
          if(!seen && vid && *vid) any_new=true;
        }
        if(any_new && snd_new && *snd_new) play_aplay(aplay_dev,snd_new);

        last_veh_n=0;
        memset(arrived_beeped,0,sizeof(arrived_beeped));
        for(int i=0;i<arrivals_n && i<32;i++){
          snprintf(last_veh_ids[last_veh_n++],sizeof(last_veh_ids[0]),"%s",arrivals[i].veh);
        }
      }

      next_fetch_ms = now_ms + (Uint32)(poll_sec*1000);
    }

    if(now_ms - last_clock_ms >= 1000){
      time_t now_epoch=time(NULL);
      for(int i=0;i<arrivals_n;i++){
        arrivals[i].eta_sec=(int)difftime(arrivals[i].eta_epoch, now_epoch);
      }
      for(int i=0;i<arrivals_n && i<32;i++){
        if(!arrived_beeped[i] && arrivals[i].eta_sec<=90 && arrivals[i].eta_sec>=0){
          if(snd_arrive && *snd_arrive) play_aplay(aplay_dev,snd_arrive);
          arrived_beeped[i]=true;
        }
      }
      last_clock_ms = now_ms;
    }

    /* render */
    SDL_SetRenderDrawColor(ren, 10,12,16,255);
    SDL_RenderClear(ren);

    SDL_Color white={240,240,240,255};
    SDL_Color soft ={180,190,205,255};
    SDL_Color accent={70,140,255,255};

    int margin=(rw>=3000)?40:24;
    int header_h=(rh>=2000)?140:96;

    SDL_Rect hdr={margin, margin, rw-2*margin, header_h};
    SDL_SetRenderDrawColor(ren, 16,22,34,255);
    SDL_RenderFillRect(ren,&hdr);

    char title[256];
    if(route_filter && *route_filter) snprintf(title,sizeof(title),"%s — Stop %s", route_filter, stop_id);
    else if(arrivals_n>0) snprintf(title,sizeof(title),"%s — Stop %s", arrivals[0].route, stop_id);
    else snprintf(title,sizeof(title),"Stop %s", stop_id);

    time_t nowt=time(NULL);
    struct tm ltm; localtime_r(&nowt,&ltm);
    char timestr[64];
    strftime(timestr,sizeof(timestr),"%a %b %d  %I:%M:%S %p",&ltm);

    Tex t_title=make_text(ren,f_title,white,title,solid);
    Tex t_time =make_text(ren,f_small,soft,timestr,solid);
    Tex t_stop =make_text(ren,f_small,soft,(last_stop_name[0]?last_stop_name:""),solid);

    int tx=hdr.x+18, ty=hdr.y+12;
    draw_tex(ren,t_title,tx,ty);
    draw_tex(ren,t_time, hdr.x+hdr.w-t_time.w-18, ty+6);
    if(t_stop.t) draw_tex(ren,t_stop, tx, ty+t_title.h+6);

    free_tex(&t_title); free_tex(&t_time); free_tex(&t_stop);

    int grid_top = hdr.y + hdr.h + 18;
    int grid_h = rh - grid_top - margin;

    int nshow=arrivals_n; if(nshow>max_buses) nshow=max_buses;

    if(nshow<=0){
      Tex msg=make_text(ren,f_body,soft,"No upcoming arrivals to display",solid);
      draw_tex(ren,msg,margin+30,grid_top+30);
      free_tex(&msg);
      SDL_RenderPresent(ren);
      SDL_Delay(16);
      continue;
    }

    int cols = (rw>=3000)?4 : (rw>=1800?3 : (rw>=1200?2:1));
    if(cols>nshow) cols=nshow;
    int rows = (nshow + cols - 1)/cols;
    if(rows<1) rows=1;

    int gap=(rw>=3000)?22:14;
    int tile_w=(rw - 2*margin - (cols-1)*gap)/cols;
    int tile_h=(grid_h - (rows-1)*gap)/rows;
    if(tile_h>10) tile_h-=6;

    for(int i=0;i<nshow;i++){
      int c=i%cols, r=i/cols;
      int x0=margin + c*(tile_w+gap);
      int y0=grid_top + r*(tile_h+gap);

      SDL_Rect tile={x0,y0,tile_w,tile_h};
      SDL_SetRenderDrawColor(ren,20,28,44,255);
      SDL_RenderFillRect(ren,&tile);

      SDL_Rect stripe={x0,y0,10,tile_h};
      SDL_SetRenderDrawColor(ren,accent.r,accent.g,accent.b,255);
      SDL_RenderFillRect(ren,&stripe);

      const Arrival *a=&arrivals[i];

      char eta_buf[16]; fmt_eta(eta_buf,sizeof(eta_buf),a->eta_sec);
      char dist_buf[128]; fmt_dist_stops(dist_buf,sizeof(dist_buf),a);

      char top_buf[128];
      if(a->veh[0]) snprintf(top_buf,sizeof(top_buf),"%s  #%s",a->route,a->veh);
      else snprintf(top_buf,sizeof(top_buf),"%s",a->route);

      SDL_Color eta_col=white;
      if(a->eta_sec<=60) eta_col=(SDL_Color){255,170,60,255};

      Tex t_top =make_text(ren,f_route,white,top_buf,solid);
      Tex t_dest=make_text(ren,f_small,soft,(a->dest[0]?a->dest:""),solid);
      Tex t_dist=make_text(ren,f_small,soft,dist_buf,solid);
      Tex t_eta =make_text(ren,f_eta,eta_col,eta_buf,solid);
      Tex t_eta_u=make_text(ren,f_small,soft,(strcmp(eta_buf,"NOW")==0?"":"min"),solid);

      int pad=18;
      int cx=x0+10+pad;
      int cy=y0+pad;

      draw_tex(ren,t_top,cx,cy);
      if(t_dest.t) draw_tex(ren,t_dest,cx,cy+t_top.h+6);

      if(t_dist.t){
        int by=y0+tile_h-pad-t_dist.h;
        draw_tex(ren,t_dist,cx,by);
      }

      int ex=x0+tile_w-pad-t_eta.w;
      int ey=y0+(tile_h/2)-(t_eta.h/2);
      draw_tex(ren,t_eta,ex,ey);
      if(t_eta_u.t) draw_tex(ren,t_eta_u, ex+t_eta.w-t_eta_u.w, ey+t_eta.h+2);

      free_tex(&t_top); free_tex(&t_dest); free_tex(&t_dist);
      free_tex(&t_eta); free_tex(&t_eta_u);

      SDL_SetRenderDrawColor(ren,35,45,70,255);
      SDL_RenderDrawRect(ren,&tile);
    }

    SDL_RenderPresent(ren);
    SDL_Delay(16);
  }

  free(arrivals);

  TTF_CloseFont(f_title);
  TTF_CloseFont(f_route);
  TTF_CloseFont(f_body);
  TTF_CloseFont(f_small);
  TTF_CloseFont(f_eta);

  SDL_DestroyRenderer(ren);
  SDL_DestroyWindow(win);
  TTF_Quit();
  SDL_Quit();
  curl_global_cleanup();
  return 0;
}
